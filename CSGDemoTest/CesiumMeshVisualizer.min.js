(function(){var e,t,n;(function(i){var r,a,o,s,l={},c={},f={},d={},u=Object.prototype.hasOwnProperty,m=[].slice,p=/\.js$/;function h(e,t){return u.call(e,t)}function v(e,t){var n,i,r,a,o,s,l,c,d,u,m,h,v=t&&t.split("/"),g=f.map,_=g&&g["*"]||{};if(e){e=e.split("/");o=e.length-1;if(f.nodeIdCompat&&p.test(e[o])){e[o]=e[o].replace(p,"")}if(e[0].charAt(0)==="."&&v){h=v.slice(0,v.length-1);e=h.concat(e)}for(d=0;d<e.length;d++){m=e[d];if(m==="."){e.splice(d,1);d-=1}else if(m===".."){if(d===0||d===1&&e[2]===".."||e[d-1]===".."){continue}else if(d>0){e.splice(d-1,2);d-=2}}}e=e.join("/")}if((v||_)&&g){n=e.split("/");for(d=n.length;d>0;d-=1){i=n.slice(0,d).join("/");if(v){for(u=v.length;u>0;u-=1){r=g[v.slice(0,u).join("/")];if(r){r=r[i];if(r){a=r;s=d;break}}}}if(a){break}if(!l&&_&&_[i]){l=_[i];c=d}}if(!a&&l){a=l;s=c}if(a){n.splice(0,s,a);e=n.join("/")}}return e}function g(e,t){return function(){var n=m.call(arguments,0);if(typeof n[0]!=="string"&&n.length===1){n.push(null)}return a.apply(i,n.concat([e,t]))}}function _(e){return function(t){return v(t,e)}}function x(e){return function(t){l[e]=t}}function C(e){if(h(c,e)){var t=c[e];delete c[e];d[e]=true;r.apply(i,t)}if(!h(l,e)&&!h(d,e)){throw new Error("No "+e)}return l[e]}function y(e){var t,n=e?e.indexOf("!"):-1;if(n>-1){t=e.substring(0,n);e=e.substring(n+1,e.length)}return[t,e]}function M(e){return e?y(e):[]}o=function(e,t){var n,i=y(e),r=i[0],a=t[1];e=i[1];if(r){r=v(r,a);n=C(r)}if(r){if(n&&n.normalize){e=n.normalize(e,_(a))}else{e=v(e,a)}}else{e=v(e,a);i=y(e);r=i[0];e=i[1];if(r){n=C(r)}}return{f:r?r+"!"+e:e,n:e,pr:r,p:n}};function w(e){return function(){return f&&f.config&&f.config[e]||{}}}s={require:function(e){return g(e)},exports:function(e){var t=l[e];if(typeof t!=="undefined"){return t}else{return l[e]={}}},module:function(e){return{id:e,uri:"",exports:l[e],config:w(e)}}};r=function(e,t,n,r){var a,f,u,m,p,v,_=[],y=typeof n,w;r=r||e;v=M(r);if(y==="undefined"||y==="function"){t=!t.length&&n.length?["require","exports","module"]:t;for(p=0;p<t.length;p+=1){m=o(t[p],v);f=m.f;if(f==="require"){_[p]=s.require(e)}else if(f==="exports"){_[p]=s.exports(e);w=true}else if(f==="module"){a=_[p]=s.module(e)}else if(h(l,f)||h(c,f)||h(d,f)){_[p]=C(f)}else if(m.p){m.p.load(m.n,g(r,true),x(f),{});_[p]=l[f]}else{throw new Error(e+" missing "+f)}}u=n?n.apply(l[e],_):undefined;if(e){if(a&&a.exports!==i&&a.exports!==l[e]){l[e]=a.exports}else if(u!==i||!w){l[e]=u}}}else if(e){l[e]=n}};e=t=a=function(e,t,n,l,c){if(typeof e==="string"){if(s[e]){return s[e](t)}return C(o(e,M(t)).f)}else if(!e.splice){f=e;if(f.deps){a(f.deps,f.callback)}if(!t){return}if(t.splice){e=t;t=n;n=null}else{e=i}}t=t||function(){};if(typeof n==="function"){n=l;l=c}if(l){r(i,e,t,n)}else{setTimeout(function(){r(i,e,t,n)},4)}return a};a.config=function(e){return a(e)};e._defined=l;n=function(e,t,n){if(typeof e!=="string"){throw new Error("See almond README: incorrect module build, no module name")}if(!t.splice){n=t;t=[]}if(!h(l,e)&&!h(c,e)){c[e]=[e,t,n]}};n.amd={jQuery:true}})();n("Core/RendererUtils",[],function(){var e=Cesium.Cartesian3;var t=Cesium.Math;var n=Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromRotationX(t.PI_OVER_TWO));var i=new Cesium.Cartesian3;var r=new Cesium.Quaternion;var a=new Cesium.Cartesian3;var o=new Cesium.Matrix4;var s=new Cesium.Matrix4;var l=new Cesium.Cartesian3;var c=new Cesium.ClearCommand({color:new Cesium.Color(0,0,0,0)});function f(){}f.renderToTexture=function(e,t,n){var i=Cesium.isArray(e)?e:[e];var r=t.context;var a=new Cesium.Framebuffer({context:r,colorTextures:[n],destroyAttachments:false});var o=c;o.framebuffer=a;o.renderState=t.renderState;o.execute(r);i.forEach(function(e){e.framebuffer=a;e.execute(r)});a.destroy()};f.yUp2Zup=function(e,t){return Cesium.Matrix4.multiplyTransformation(e,n,t)};f.computeModelMatrix=function(n,s,l,c,f){if(arguments.length==0){return n}var d=Cesium.Matrix4;if(!f){f=new d}d.clone(n,f);if(!s){i.x=0;i.y=0;i.z=0}i.x=s.x;i.y=s.y;i.z=s.z;if(!c){a.x=0;a.y=0;a.z=0}a.x=c.x;a.y=c.y;a.z=c.z;if(l instanceof Cesium.Quaternion){Cesium.Quaternion.clone(l,r)}else{var u=l.axis;var m=l.angle;Cesium.Quaternion.fromAxisAngle(new e(u.x,u.y,u.z),t.toRadians(m),r)}d.fromTranslationQuaternionRotationScale(i,r,a,o);d.multiplyTransformation(f,o,f);return f};return f});n("Core/Rotation",[],function(){function e(e,t){this._axis=e;this._angle=t;this.paramChanged=new Cesium.Event}Cesium.defineProperties(e.prototype,{axis:{set:function(e){if(e.x!=this._axis.x||e.y!=this._axis.y||e.z!=this._axis.z){this._axis=e;this.paramChanged.raiseEvent()}this._axis=e},get:function(){return this._axis}},angle:{set:function(e){if(e!=this._angle){this._angle=e;this.paramChanged.raiseEvent()}this._angle=e},get:function(){return this._angle}}});return e});n("Util/CSG",[],function(){function e(){this.polygons=[]}e.fromPolygons=function(t){var n=new e;n.polygons=t;return n};e.prototype={clone:function(){var t=new e;t.polygons=this.polygons.map(function(e){return e.clone()});return t},toPolygons:function(){return this.polygons},union:function(t){var n=new e.Node(this.clone().polygons);var i=new e.Node(t.clone().polygons);n.clipTo(i);i.clipTo(n);i.invert();i.clipTo(n);i.invert();n.build(i.allPolygons());return e.fromPolygons(n.allPolygons())},subtract:function(t){var n=new e.Node(this.clone().polygons);var i=new e.Node(t.clone().polygons);n.invert();n.clipTo(i);i.clipTo(n);i.invert();i.clipTo(n);i.invert();n.build(i.allPolygons());n.invert();return e.fromPolygons(n.allPolygons())},intersect:function(t){var n=new e.Node(this.clone().polygons);var i=new e.Node(t.clone().polygons);n.invert();i.clipTo(n);i.invert();n.clipTo(i);i.clipTo(n);n.build(i.allPolygons());n.invert();return e.fromPolygons(n.allPolygons())},inverse:function(){var e=this.clone();e.polygons.map(function(e){e.flip()});return e}};e.cube=function(t){t=t||{};var n=new e.Vector(t.center||[0,0,0]);var i=!t.radius?[1,1,1]:t.radius.length?t.radius:[t.radius,t.radius,t.radius];return e.fromPolygons([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[+1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,+1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,+1]]].map(function(t){return new e.Polygon(t[0].map(function(r){var a=new e.Vector(n.x+i[0]*(2*!!(r&1)-1),n.y+i[1]*(2*!!(r&2)-1),n.z+i[2]*(2*!!(r&4)-1));return new e.Vertex(a,new e.Vector(t[1]))}))}))};e.sphere=function(t){t=t||{};var n=new e.Vector(t.center||[0,0,0]);var i=t.radius||1;var r=t.slices||16;var a=t.stacks||8;var o=[],s;function l(t,r){t*=Math.PI*2;r*=Math.PI;var a=new e.Vector(Math.cos(t)*Math.sin(r),Math.cos(r),Math.sin(t)*Math.sin(r));s.push(new e.Vertex(n.plus(a.times(i)),a))}for(var c=0;c<r;c++){for(var f=0;f<a;f++){s=[];l(c/r,f/a);if(f>0)l((c+1)/r,f/a);if(f<a-1)l((c+1)/r,(f+1)/a);l(c/r,(f+1)/a);o.push(new e.Polygon(s))}}return e.fromPolygons(o)};e.cylinder=function(t){t=t||{};var n=new e.Vector(t.start||[0,-1,0]);var i=new e.Vector(t.end||[0,1,0]);var r=i.minus(n);var a=t.radius||1;var o=t.slices||16;var s=r.unit(),l=Math.abs(s.y)>.5;var c=new e.Vector(l,!l,0).cross(s).unit();var f=c.cross(s).unit();var d=new e.Vertex(n,s.negated());var u=new e.Vertex(i,s.unit());var m=[];function p(t,i,o){var l=i*Math.PI*2;var d=c.times(Math.cos(l)).plus(f.times(Math.sin(l)));var u=n.plus(r.times(t)).plus(d.times(a));var m=d.times(1-Math.abs(o)).plus(s.times(o));return new e.Vertex(u,m)}for(var h=0;h<o;h++){var v=h/o,g=(h+1)/o;m.push(new e.Polygon([d,p(0,v,-1),p(0,g,-1)]));m.push(new e.Polygon([p(0,g,0),p(0,v,0),p(1,v,0),p(1,g,0)]));m.push(new e.Polygon([u,p(1,g,1),p(1,v,1)]))}return e.fromPolygons(m)};e.Vector=function(e,t,n){if(arguments.length==3){this.x=e;this.y=t;this.z=n}else if("x"in e){this.x=e.x;this.y=e.y;this.z=e.z}else{this.x=e[0];this.y=e[1];this.z=e[2]}};e.Vector.prototype={clone:function(){return new e.Vector(this.x,this.y,this.z)},negated:function(){return new e.Vector(-this.x,-this.y,-this.z)},plus:function(t){return new e.Vector(this.x+t.x,this.y+t.y,this.z+t.z)},minus:function(t){return new e.Vector(this.x-t.x,this.y-t.y,this.z-t.z)},times:function(t){return new e.Vector(this.x*t,this.y*t,this.z*t)},dividedBy:function(t){return new e.Vector(this.x/t,this.y/t,this.z/t)},dot:function(e){return this.x*e.x+this.y*e.y+this.z*e.z},lerp:function(e,t){return this.plus(e.minus(this).times(t))},length:function(){return Math.sqrt(this.dot(this))},unit:function(){return this.dividedBy(this.length())},cross:function(t){return new e.Vector(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}};e.Vertex=function(t,n){this.pos=new e.Vector(t);this.normal=new e.Vector(n)};e.Vertex.prototype={clone:function(){return new e.Vertex(this.pos.clone(),this.normal.clone())},flip:function(){this.normal=this.normal.negated()},interpolate:function(t,n){return new e.Vertex(this.pos.lerp(t.pos,n),this.normal.lerp(t.normal,n))}};e.Plane=function(e,t){this.normal=e;this.w=t};e.Plane.EPSILON=1e-5;e.Plane.fromPoints=function(t,n,i){var r=n.minus(t).cross(i.minus(t)).unit();return new e.Plane(r,r.dot(t))};e.Plane.prototype={clone:function(){return new e.Plane(this.normal.clone(),this.w)},flip:function(){this.normal=this.normal.negated();this.w=-this.w},splitPolygon:function(t,n,i,r,a){var o=0;var s=1;var l=2;var c=3;var f=0;var d=[];for(var u=0;u<t.vertices.length;u++){var m=this.normal.dot(t.vertices[u].pos)-this.w;var p=m<-e.Plane.EPSILON?l:m>e.Plane.EPSILON?s:o;f|=p;d.push(p)}switch(f){case o:(this.normal.dot(t.plane.normal)>0?n:i).push(t);break;case s:r.push(t);break;case l:a.push(t);break;case c:var h=[],v=[];for(var u=0;u<t.vertices.length;u++){var g=(u+1)%t.vertices.length;var _=d[u],x=d[g];var C=t.vertices[u],y=t.vertices[g];if(_!=l)h.push(C);if(_!=s)v.push(_!=l?C.clone():C);if((_|x)==c){var m=(this.w-this.normal.dot(C.pos))/this.normal.dot(y.pos.minus(C.pos));var M=C.interpolate(y,m);h.push(M);v.push(M.clone())}}if(h.length>=3)r.push(new e.Polygon(h,t.shared));if(v.length>=3)a.push(new e.Polygon(v,t.shared));break}}};e.Polygon=function(t,n){this.vertices=t;this.shared=n;this.plane=e.Plane.fromPoints(t[0].pos,t[1].pos,t[2].pos)};e.Polygon.prototype={clone:function(){var t=this.vertices.map(function(e){return e.clone()});return new e.Polygon(t,this.shared)},flip:function(){this.vertices.reverse().map(function(e){e.flip()});this.plane.flip()}};e.Node=function(e){this.plane=null;this.front=null;this.back=null;this.polygons=[];if(e)this.build(e)};e.Node.prototype={clone:function(){var t=new e.Node;t.plane=this.plane&&this.plane.clone();t.front=this.front&&this.front.clone();t.back=this.back&&this.back.clone();t.polygons=this.polygons.map(function(e){return e.clone()});return t},invert:function(){for(var e=0;e<this.polygons.length;e++){this.polygons[e].flip()}this.plane.flip();if(this.front)this.front.invert();if(this.back)this.back.invert();var t=this.front;this.front=this.back;this.back=t},clipPolygons:function(e){if(!this.plane)return e.slice();var t=[],n=[];for(var i=0;i<e.length;i++){this.plane.splitPolygon(e[i],t,n,t,n)}if(this.front)t=this.front.clipPolygons(t);if(this.back)n=this.back.clipPolygons(n);else n=[];return t.concat(n)},clipTo:function(e){this.polygons=e.clipPolygons(this.polygons);if(this.front)this.front.clipTo(e);if(this.back)this.back.clipTo(e)},allPolygons:function(){var e=this.polygons.slice();if(this.front)e=e.concat(this.front.allPolygons());if(this.back)e=e.concat(this.back.allPolygons());return e},build:function(t){if(!t.length)return;if(!this.plane)this.plane=t[0].plane.clone();var n=[],i=[];for(var r=0;r<t.length;r++){this.plane.splitPolygon(t[r],this.polygons,this.polygons,n,i)}if(n.length){if(!this.front)this.front=new e.Node;this.front.build(n)}if(i.length){if(!this.back)this.back=new e.Node;this.back.build(i)}}};e.toCSG=function(t,n){if(!n){n={x:0,y:0,z:0}}if(!t.attributes.normal){t=Cesium.GeometryPipeline.computeNormal(t)}if(t.primitiveType!==Cesium.PrimitiveType.TRIANGLES){throw new Error("暂不支持此类几何体")}if(!e){throw new Error("CSG 库未加载。请从 https://github.com/evanw/csg.js 获取")}var i=t.indices.length/3;var r=[],a=[];var o=t.attributes.position.values;var s=t.attributes.normal.values;var l=0,c=0;for(var f=0;f<t.indices.length;f+=3){a=[];var d=t.indices[f];var u=t.indices[f+1];var m=t.indices[f+2];c=d*3;l=d*3;a.push(new e.Vertex([o[c++]+n.x,o[c++]+n.y,o[c++]+n.z],[s[l++],s[l++],s[l++]]));c=u*3;l=u*3;a.push(new e.Vertex([o[c++]+n.x,o[c++]+n.y,o[c++]+n.z],[s[l++],s[l++],s[l++]]));c=m*3;l=m*3;a.push(new e.Vertex([o[c++]+n.x,o[c++]+n.y,o[c++]+n.z],[s[l++],s[l++],s[l++]]));r.push(new e.Polygon(a))}return e.fromPolygons(r)};e.fromCSG=function(t){var n,i,r,a=t.toPolygons();if(!e){throw new Error("CSG 库未加载。请从 https://github.com/evanw/csg.js 获取")}var o=[];var s=[];var l=[];for(n=0;n<a.length;n++){r=[];for(i=0;i<a[n].vertices.length;i++){r.push(this.getGeometryVertice(o,s,a[n].vertices[i].pos,a[n].plane.normal))}if(r[0]===r[r.length-1]){r.pop()}for(var i=2;i<r.length;i++){l.push(r[0],r[i-1],r[i])}}o=new Float32Array(o);s=new Float32Array(s);l=new Int32Array(l);var c={};c.position=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:o});c.normal=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:s});var f=new Cesium.Geometry({attributes:c,indices:l,primitiveType:Cesium.PrimitiveType.TRIANGLES});return f},e.getGeometryVertice=function(e,t,n,i){var r,a=0;for(r=0;r<e.length;r+=3){if(e[r]===n.x&&e[r+1]===n.y&&e[r+2]===n.z){return a}a++}e.push(n.x,n.y,n.z);t.push(i.x,i.y,i.z);return a};return e});n("Util/defineProperty",[],function(){function e(e,t,n,i){e["_"+t]=n;var r={get:function(){return this["_"+t]},set:function(n){var r=n!=this["_"+t];if(this["_"+t].equals){r=this["_"+t].equals(n)}this["_"+t]=n;if(typeof i=="function"&&r){i(r,e)}}};var a={};a[t]=r;Cesium.defineProperties(e,a)}return e});n("Core/MeshMaterial",["Util/defineProperty"],function(e){var t=Cesium.defaultValue;function n(i){i=t(i,{});i.uniforms=t(i.uniforms,{});var r=this;this._uuid=Cesium.createGuid();function a(t){var n={};for(var i in t){if(t.hasOwnProperty(i)&&Cesium.defined(t[i])){var r=t[i];var a={};a.needsUpdate=true;if(Cesium.isArray(r)&&r.length>=3&&r.length<=4&&typeof r[0]==="number"){t[i]=new Cesium.Color(t[i][0],t[i][1],t[i][2],t[i][3])}else if(Cesium.defined(r.value)){for(var o in r){if(r.hasOwnProperty(o)){a[o]=r[o]}}}if(t[i].hasOwnProperty("uuid")){e(a,"uuid",t[i].uuid,function(e,t){t.needsUpdate=e})}else{e(a,"uuid",Cesium.createGuid(),function(e,t){t.needsUpdate=e})}if(t[i].hasOwnProperty("value")){e(a,"value",t[i].value,function(e,t){t.needsUpdate=e})}else{e(a,"value",t[i],function(e,t){t.needsUpdate=e})}n[i]=a}}return n}this._defaultColor=t(i.defaultColor,Cesium.Color.WHITE);if(typeof this._defaultColor=="string"){this._defaultColor=Cesium.Color.fromCssColorString(this._defaultColor)}this._pickedColor=t(i.pickedColor,Cesium.Color.YELLOW);if(typeof this._pickedColor=="string"){this._pickedColor=Cesium.Color.fromCssColorString(this._pickedColor)}this._picked=t(i.picked,0);i.uniforms.pickedColor=this._pickedColor;i.uniforms.defaultColor=this._defaultColor;i.uniforms.picked=this._picked;this._uniforms=a(i.uniforms);function o(e){r.needsUpdate=e}e(this,"translucent",t(i.translucent,false),o);e(this,"wireframe",t(i.wireframe,false),o);e(this,"side",t(i.side,n.Sides.DOUBLE),o);e(this,"uniformStateUsed",t(i.uniformStateUsed,[{uniformStateName:"model",glslVarName:"modelMatrix"}]),o);e(this,"uniforms",this._uniforms,function(){r._uniforms=a(r._uniforms)});this._vertexShader="//#inner\n void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}";this._fragmentShader="//#inner"+this._uuid+"\n uniform float picked;\n uniform vec4  pickedColor;\n uniform vec4  defaultColor;\n void main() {\ngl_FragColor = defaultColor;\n if(picked!=0.0){\ngl_FragColor = pickedColor;}}";e(this,"vertexShader",t(i.vertexShader,this._vertexShader),o);e(this,"fragmentShader",t(i.fragmentShader,this._fragmentShader),o);this.depthTest=true;this.depthMask=true;this.blending=true;this.needsUpdate=true}Cesium.defineProperties(n.prototype,{uuid:{get:function(){return this._uuid}},defaultColor:{set:function(e){if(typeof e=="string"){e=Cesium.Color.fromCssColorString(e)}Cesium.Color.clone(e,this._defaultColor)},get:function(){return this._defaultColor}}});n.Sides={FRONT:3,BACK:1,DOUBLE:2};return n});n("Core/GeometryUtils",["Util/CSG"],function(e){function t(){}function n(e){var t=[];for(var n in e.attributes){if(e.attributes.hasOwnProperty(n)&&e.attributes[n]){t.push(n)}}return t}var i=new Cesium.Cartesian3;var r=new Cesium.Quaternion;var a=new Cesium.Matrix4;var o=new Cesium.Matrix3;t.rotateX=function(e,t){var n=e.attributes.position.values;Cesium.Matrix3.fromRotationX(t,o);Cesium.Matrix4.fromRotationTranslation(o,Cesium.Cartesian3.ZERO,a);for(var r=0;r<n.length;r+=3){i.x=n[r];i.y=n[r+1];i.z=n[r+2];Cesium.Matrix4.multiplyByPoint(a,i,i);n[r]=i.x;n[r+1]=i.y;n[r+2]=i.z}};t.rotateY=function(e,t){var n=e.attributes.position.values;Cesium.Matrix3.fromRotationY(t,o);Cesium.Matrix4.fromRotationTranslation(o,Cesium.Cartesian3.ZERO,a);for(var r=0;r<n.length;r+=3){i.x=n[r];i.y=n[r+1];i.z=n[r+2];Cesium.Matrix4.multiplyByPoint(a,i,i);n[r]=i.x;n[r+1]=i.y;n[r+2]=i.z}};t.rotateZ=function(e,t){var n=e.attributes.position.values;Cesium.Matrix3.fromRotationZ(t,o);Cesium.Matrix4.fromRotationTranslation(o,Cesium.Cartesian3.ZERO,a);for(var r=0;r<n.length;r+=3){i.x=n[r];i.y=n[r+1];i.z=n[r+2];Cesium.Matrix4.multiplyByPoint(a,i,i);n[r]=i.x;n[r+1]=i.y;n[r+2]=i.z}};t.computeVertexNormals=function(e){var t=e.indices;var n=e.attributes;var i=t.length;if(n.position){var r=n.position.values;if(n.normal===undefined){n.normal=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:new Float32Array(r.length)})}else{var a=n.normal.values;for(var o=0;o<i;o++){a[o]=0}}var l=n.normal.values;var c,f,d;var u=new Cesium.Cartesian3,m=new Cesium.Cartesian3,p=new Cesium.Cartesian3;var h=new Cesium.Cartesian3,v=new Cesium.Cartesian3;for(var o=0;o<i;o+=3){c=t[o+0]*3;f=t[o+1]*3;d=t[o+2]*3;Cesium.Cartesian3.fromArray(r,c,u);Cesium.Cartesian3.fromArray(r,f,m);Cesium.Cartesian3.fromArray(r,d,p);Cesium.Cartesian3.subtract(p,m,h);Cesium.Cartesian3.subtract(u,m,v);Cesium.Cartesian3.cross(h,v,h);l[c]+=h.x;l[c+1]+=h.y;l[c+2]+=h.z;l[f]+=h.x;l[f+1]+=h.y;l[f+2]+=h.z;l[d]+=h.x;l[d+1]+=h.y;l[d+2]+=h.z}s(e);n.normal.needsUpdate=true}return e};function s(e){var t=e.attributes.normal.values;var n,i,r,a;for(var o=0;o<t.length;o+=3){n=t[o];i=t[o+1];r=t[o+2];a=1/Math.sqrt(n*n+i*i+r*r);t[o]=n*a;t[o+1]=i*a;t[o+2]=r*a}}t.mergeGeometries=function(e){if(!e||!e.length){throw new Error("缺少geometries参数")}if(e.length==1){return e[0]}var t=[];var i=false;var r=false;var a=e[0].primitiveType;for(var o=0;o<e.length;o++){t[o]=n(e[o]);if(o>0){if(a!=e[o].primitiveType){r=true;break}var s=t[o-1];i=s.length!=t[o].length;if(!i){for(var l=0;l<s.length;l++){if(s[l]!=t[o][l]){i=true;break}}}}a=e[o].primitiveType;if(i||r){break}}if(r){throw new Error("待合并的几何体中primitiveType属性不完全一致")}if(i){throw new Error("待合并的几何体中属性数量和和名称不完全一致")}var c={};var f=t[0];for(var o=0;o<f.length;o++){var d=f[o];var u=e[0];c[d]={};for(var m in u.attributes[d]){if(u.attributes[d].hasOwnProperty(m)){c[d][m]=u.attributes[d][m]}}var p=Array.from(c[d].values);for(var l=1;l<e.length;l++){u=e[l];for(var h=0;h<u.attributes[d].values.length;h++){p.push(u.attributes[d].values[h])}}c[d].values=new c[d].values.constructor(p)}var v=[];var g=0;for(var l=0;l<e.length;l++){var u=e[0];for(var o=0;o<u.indices.length;o++){v.push(u.indices[o]+g)}g+=u.attributes.position.values.length/3}var _=Cesium.BoundingSphere.fromVertices(c.position.values);var x=new Cesium.Geometry({attributes:c,indices:new Int32Array(v),primitiveType:e[0].primitiveType,boundingSphere:_});return x};var l=new Cesium.Cartesian3;t.translate=function(e,t){if(Cesium.isArray(t)){l.x=t[0];l.y=t[1];l.z=t[2]}else{Cesium.Cartesian3.clone(t,l)}for(var n=0;n<e.attributes.position.values.length;n+=3){e.attributes.position.values[n]+=l.x;e.attributes.position.values[n+1]+=l.y;e.attributes.position.values[n+2]+=l.z}};t.getAttributeComponentType=function(e){var t=Cesium.ComponentDatatype.SHORT;if(e instanceof Int8Array){t=Cesium.ComponentDatatype.BYTE}else if(e instanceof Uint8Array||e instanceof Uint8ClampedArray){t=Cesium.ComponentDatatype.UNSIGNED_BYTE}else if(e instanceof Int16Array){t=Cesium.ComponentDatatype.SHORT}else if(e instanceof Uint16Array){t=Cesium.ComponentDatatype.UNSIGNED_SHORT}else if(e instanceof Int32Array){t=Cesium.ComponentDatatype.INT}else if(e instanceof Uint32Array){t=Cesium.ComponentDatatype.UNSIGNED_INT}else if(e instanceof Float32Array){t=Cesium.ComponentDatatype.FLOAT}else if(e instanceof Float64Array){t=Cesium.ComponentDatatype.DOUBLE}return t};t.isGeometry3js=function(e){return typeof THREE!=="undefined"&&(e instanceof THREE.Geometry||e instanceof THREE.BufferGeometry)||e.attributes&&e.attributes.position&&e.index||e.vertices&&e.faces};t.parseBufferGeometry3js=function(e){var n={};if(!e.attributes.normal){e.computeFaceNormals()}for(var i in e.attributes){if(e.attributes.hasOwnProperty(i)){var r=e.getAttribute(i);if(r&&r.array.length>0){n[i]=new Cesium.GeometryAttribute({componentDatatype:t.getAttributeComponentType(r.array),componentsPerAttribute:r.itemSize,values:r.array,normalize:r.normalized})}}}var a=[];if(!e.index&&e.groups){e.groups.forEach(function(e){for(var t=0;t<e.count;t++){a.push(t+e.start)}});a=new Int32Array(a)}else{a=e.index.array}var o=new Cesium.Geometry({attributes:n,indices:a,primitiveType:Cesium.PrimitiveType.TRIANGLES});return o};t.fromGeometry3js=function(e){if(e.attributes&&(e.index||e.groups.length)){return t.parseBufferGeometry3js(e)}var n=new Float32Array(e.vertices.length*3);for(var i=0;i<e.vertices.length;i++){n[i*3]=e.vertices[i].x;if(!e.up||e.up.y){n[i*3+1]=e.vertices[i].z;n[i*3+2]=e.vertices[i].y}else{n[i*3+1]=e.vertices[i].y;n[i*3+2]=e.vertices[i].z}}var r=new Int32Array(e.faces.length*3);for(var i=0;i<e.faces.length;i++){r[i*3]=e.faces[i].a;r[i*3+1]=e.faces[i].b;r[i*3+2]=e.faces[i].c}var a={};a.position=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:n});var o=new Cesium.Geometry({attributes:a,indices:r,primitiveType:Cesium.PrimitiveType.TRIANGLES});return o};t.toGeometry3js=function(e){if(typeof THREE==="undefined"){throw new Error("THREE 未加载")}var t=e.attributes.position.values;var n=0;var i=new THREE.Geometry;for(var r=0;r<t.length;r+=3){n=r*3;i.vertices.push(new THREE.Vector3(t[n],t[n+2],t[n+1]))}for(var r=0;r<e.indices.length;r+=3){var a=e.indices[r];var o=e.indices[r+1];var s=e.indices[r+2];i.faces.push(new THREE.Face3(a,o,s))}return i};t.toCSG=function(n,i){if(!(typeof THREE==="undefined")){if(n instanceof THREE.Geometry){return t._toCSG3js(n,i)}}if(!i){i={x:0,y:0,z:0}}if(!n.attributes.normal){n=Cesium.GeometryPipeline.computeNormal(n)}if(n.primitiveType!==Cesium.PrimitiveType.TRIANGLES){throw new Error("暂不支持此类几何体")}if(!e){throw new Error("CSG 库未加载。请从 https://github.com/evanw/csg.js 获取")}var r=n.indices.length/3;var a=[],o=[];var s=n.attributes.position.values;var l=n.attributes.normal.values;var c=0,f=0;for(var d=0;d<n.indices.length;d+=3){o=[];var u=n.indices[d];var m=n.indices[d+1];var p=n.indices[d+2];f=u*3;c=u*3;o.push(new e.Vertex([s[f++]+i.x,s[f++]+i.y,s[f++]+i.z],[l[c++],l[c++],l[c++]]));f=m*3;c=m*3;o.push(new e.Vertex([s[f++]+i.x,s[f++]+i.y,s[f++]+i.z],[l[c++],l[c++],l[c++]]));f=p*3;c=p*3;o.push(new e.Vertex([s[f++]+i.x,s[f++]+i.y,s[f++]+i.z],[l[c++],l[c++],l[c++]]));a.push(new e.Polygon(o))}return e.fromPolygons(a)};t.fromCSG=function(n,i){if(!(typeof THREE==="undefined")){if(geometry instanceof THREE.Geometry){return t._fromCSG3js(geometry,offset)}}var r,a,o,s=n.toPolygons();if(!e){throw new Error("CSG 库未加载。请从 https://github.com/evanw/csg.js 获取")}var l=[];var c=[];var f=[];for(r=0;r<s.length;r++){o=[];for(a=0;a<s[r].vertices.length;a++){o.push(this.getGeometryVertice(l,c,s[r].vertices[a].pos,s[r].plane.normal))}if(o[0]===o[o.length-1]){o.pop()}for(var a=2;a<o.length;a++){f.push(o[0],o[a-1],o[a])}}l=new Float32Array(l);c=new Float32Array(c);f=new Int32Array(f);var d={};d.position=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:l});d.normal=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c});var u=new Cesium.Geometry({attributes:d,indices:f,primitiveType:Cesium.PrimitiveType.TRIANGLES});return u};t._toCSG3js=function(t,n,i){if(typeof THREE==="undefined"){throw new Error("THREE 未加载")}var r,a,o,s,l;if(!e){throw"CSG library not loaded. Please get a copy from https://github.com/evanw/csg.js"}if(t instanceof THREE.Mesh){a=t.geometry;n=n||t.position;i=i||t.rotation}else if(t instanceof THREE.Geometry){a=t;n=n||new THREE.Vector3(0,0,0);i=i||new THREE.Euler(0,0,0)}else{throw"Model type not supported."}l=(new THREE.Matrix4).makeRotationFromEuler(i);var o=[];for(r=0;r<a.faces.length;r++){if(a.faces[r]instanceof THREE.Face3){s=[];s.push(new e.Vertex(a.vertices[a.faces[r].a].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));s.push(new e.Vertex(a.vertices[a.faces[r].b].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));s.push(new e.Vertex(a.vertices[a.faces[r].c].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));o.push(new e.Polygon(s))}else if(a.faces[r]instanceof THREE.Face4){s=[];s.push(new e.Vertex(a.vertices[a.faces[r].a].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));s.push(new e.Vertex(a.vertices[a.faces[r].b].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));s.push(new e.Vertex(a.vertices[a.faces[r].d].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));o.push(new e.Polygon(s));s=[];s.push(new e.Vertex(a.vertices[a.faces[r].b].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));s.push(new e.Vertex(a.vertices[a.faces[r].c].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));s.push(new e.Vertex(a.vertices[a.faces[r].d].clone().add(n).applyMatrix4(l),[a.faces[r].normal.x,a.faces[r].normal.y,a.faces[r].normal.z]));o.push(new e.Polygon(s))}else{throw"Model contains unsupported face."}}return e.fromPolygons(o)};t._fromCSG3js=function(n){if(typeof THREE==="undefined"){throw new Error("THREE 未加载")}var i,r,a,o,s=new THREE.Geometry,l=n.toPolygons();if(!e){throw"CSG library not loaded. Please get a copy from https://github.com/evanw/csg.js"}for(i=0;i<l.length;i++){a=[];for(r=0;r<l[i].vertices.length;r++){a.push(t._getGeometryVertice3js(s,l[i].vertices[r].pos))}if(a[0]===a[a.length-1]){a.pop()}for(var r=2;r<a.length;r++){o=new THREE.Face3(a[0],a[r-1],a[r],(new THREE.Vector3).copy(l[i].plane.normal));s.faces.push(o);s.faceVertexUvs[0].push(new THREE.Vector2)}}s.computeBoundingBox();return s},t._getGeometryVertice3js=function(e,t){var n;for(n=0;n<e.vertices.length;n++){if(e.vertices[n].x===t.x&&e.vertices[n].y===t.y&&e.vertices[n].z===t.z){return n}}e.vertices.push(new THREE.Vector3(t.x,t.y,t.z));return e.vertices.length-1};return t});n("Core/Shaders/phong_frag",[],function(){var e="\nvarying vec3 v_position;\nvarying vec3 v_normal;\nuniform float picked;\nuniform vec4  pickedColor;\nuniform vec4  defaultColor;\nuniform float specular;\nuniform float shininess;\nuniform vec3  emission;\nvoid main() {\n    vec3 positionToEyeEC = -v_position; \n    vec3 normalEC =normalize(v_normal);\n    vec4 color=defaultColor;\n    if(picked!=0.0){\n        gl_FragColor = pickedColor;\n    }\n    czm_material material;\n    material.specular = specular;\n    material.shininess = shininess;\n    material.normal =  normalEC;\n    material.emission =emission;//vec3(0.2,0.2,0.2);\n    material.diffuse = color.rgb ;\n    material.alpha =  color.a;\n    gl_FragColor =  czm_phong(normalize(positionToEyeEC), material);\n}";return e});n("Core/Shaders/phong_vert",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\n\n\nvarying vec3 v_position;\nvarying vec3 v_normal;\n\nvarying vec3 v_light0Direction;\n\nvoid main(void) \n{\n    vec4 pos =  modelViewMatrix * vec4( position,1.0);\n    v_normal =  normalMatrix *  normal;\n    v_position = pos.xyz;\n    v_light0Direction = mat3( modelViewMatrix) * vec3(1.0,1.0,1.0);\n    gl_Position =  projectionMatrix * pos;\n}";return e});n("Core/MeshPhongMaterial",["Core/MeshMaterial","Core/Shaders/phong_frag","Core/Shaders/phong_vert"],function(e,t,n){function i(i){i=i?i:{};i.uniforms=i.uniforms?i.uniforms:{shininess:-1,emission:[0,0,0],specular:0};i.uniforms.shininess=Cesium.defaultValue(i.uniforms.shininess,0);i.uniforms.emission=Cesium.defaultValue(i.uniforms.emission,[.2,.2,.2]);i.uniforms.specular=Cesium.defaultValue(i.uniforms.specular,0);e.apply(this,arguments);this.vertexShader=n;this.fragmentShader=t}i.prototype=new e;return i});n("Core/Mesh",["Core/Rotation","Util/CSG","Core/MeshMaterial","Core/GeometryUtils","Core/MeshPhongMaterial"],function(e,t,n,i,r){var a=Cesium.defaultValue;function o(s){if(o.isGeometrySupported(s)){var l=s;s={geometry:l,material:arguments[1]}}if(!s||!s.geometry){throw new Error("geometry是必须参数")}if(!o.isGeometrySupported(s.geometry)){throw new Error("暂不支持此类型的geometry")}if(i.isGeometry3js(s.geometry)){s.geometry=i.fromGeometry3js(s.geometry)}else if(s.geometry instanceof t){if(s.geometry.polygons.length==0){s.show=false}s.geometry=t.fromCSG(s.geometry)}else if(typeof s.geometry.constructor.createGeometry=="function"){s.geometry=s.geometry.constructor.createGeometry(s.geometry)}this.uuid=Cesium.createGuid();this.show=a(s.show,true);this._geometry=s.geometry;this._material=a(s.material,new n);this._position=a(s.position,new Cesium.Cartesian3(0,0,0));this._scale=a(s.scale,new Cesium.Cartesian3(1,1,1));this._rotation=a(s.rotation,{axis:new Cesium.Cartesian3(0,0,1),angle:0});this._rotation=new e(this._rotation.axis,this._rotation.angle);this._needsUpdate=false;this._modelMatrix=new Cesium.Matrix4;Cesium.Matrix4.clone(Cesium.Matrix4.IDENTITY,this._modelMatrix);this.quaternion=null;this._modelMatrixNeedsUpdate=true;this._onNeedUpdateChanged=function(){this.modelMatrixNeedsUpdate=true};this._rotation.paramChanged.removeEventListener(this._onNeedUpdateChanged);this._drawCommand=null;this._children=[];this._parent=null;this.userData={};if(!this._geometry.attributes.normal&&this.material instanceof r&&this._geometry.primitiveType==Cesium.PrimitiveType.TRIANGLES){Cesium.GeometryPipeline.computeNormal(this._geometry)}}o.isGeometrySupported=function(e){var n=e instanceof Cesium.Geometry||e instanceof t||typeof e.constructor.createGeometry=="function"||i.isGeometry3js(e);return n};o.traverse=function(e,t){t(e);if(e.children){e.children.forEach(function(e){t(e)})}};Cesium.defineProperties(o.prototype,{modelMatrix:{get:function(){return this._modelMatrix}},parent:{get:function(){return this._parent},set:function(e){this._parent=e;this.modelMatrixNeedsUpdate=true}},modelMatrixNeedsUpdate:{get:function(){return this._modelMatrixNeedsUpdate},set:function(e){this._modelMatrixNeedsUpdate=e;if(this._modelMatrixNeedsUpdate){o.traverse(this,function(t){t._modelMatrixNeedsUpdate=e})}}},children:{get:function(){return this._children},set:function(e){this._children=e;this._needsUpdate=true}},geometry:{get:function(){return this._geometry},set:function(e){this._geometry=e;this._needsUpdate=true;this.modelMatrixNeedsUpdate=true}},material:{get:function(){return this._material},set:function(e){this._material=e;this._needsUpdate=true}},needsUpdate:{get:function(){return this._needsUpdate},set:function(e){this._needsUpdate=e}},rotation:{get:function(){return this._rotation},set:function(e){if(e!=this._rotation){this._rotation=e;this.modelMatrixNeedsUpdate=true}
this._rotation.paramChanged.removeEventListener(this._onNeedUpdateChanged);this._rotation=e;this._rotation.paramChanged.addEventListener(this._onNeedUpdateChanged)}},position:{get:function(){return this._position},set:function(e){if(e.x!=this._position.x||e.y!=this._position.y||e.z!=this._position.z){this._position=e;this.modelMatrixNeedsUpdate=true}this._position=e}},scale:{get:function(){return this._scale},set:function(e){if(e.x!=this._scale.x||e.y!=this._scale.y||e.z!=this._scale.z){this._scale=e;this.modelMatrixNeedsUpdate=true}this._scale=e}}});o.prototype.add=function(e){if(e.parent!==this){e.parent=this}this._children.push(e)};return o});n("Core/Shaders/none_frag",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\nvarying vec3 v_position;\n\nuniform vec4 ambientColor;\nuniform vec4 diffuseColor;\nuniform vec4 specularColor;\nuniform float specularShininess;\nuniform float picked;\nuniform vec4  pickedColor;\n\nvoid main(void) \n{\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 ambient = ambientColor;\n    vec4 diffuse = diffuseColor;\n    vec4 specular = specularColor;\n    color.xyz += ambient.xyz;\n    color.xyz += diffuse.xyz;\n    color.xyz += specular.xyz;\n    color = vec4(color.rgb * diffuse.a, diffuse.a);\n    gl_FragColor = color;\n    if(picked!=0.0){\n        gl_FragColor =mix(color, pickedColor*0.5,1.0);\n    }\n}";return e});n("Core/Shaders/none_vert",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\n\n\nvarying vec3 v_position;\n\nvoid main(void) \n{\n    vec4 pos =  modelViewMatrix * vec4( position,1.0);\n    v_position = pos.xyz;\n    gl_Position =  projectionMatrix * pos;\n}";return e});n("Core/Shaders/normals_frag",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\nvarying vec3 v_position;\nvarying vec3 v_normal;\n\nuniform vec4 ambientColor;\nuniform vec4 diffuseColor;\nuniform vec4 specularColor;\nuniform float specularShininess;\nuniform float alpha;\nuniform float picked;\nuniform vec4  pickedColor;\n\nvarying vec3 v_light0Direction;\n\nvoid main(void) \n{\n    vec3 normal = normalize(v_normal);\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\n    vec3 lightColor = vec3(1.0,1.0,1.0);\nvec4 ambient = ambientColor;\n    vec4 diffuse = diffuseColor;\n    vec4 specular = specularColor;\n\n    vec3 specularLight = vec3(0.0, 0.0, 0.0);\n    {\n        float specularIntensity = 0.0;\n        float attenuation = 1.0;\n        vec3 l = normalize(v_light0Direction);\n        vec3 viewDir = -normalize(v_position);\n        vec3 h = normalize(l+viewDir);\n        specularIntensity = max(0.0, pow(max(dot(normal,h), 0.0) , specularShininess)) * attenuation;\n        specularLight += lightColor * specularIntensity;\n        diffuseLight += lightColor * max(dot(normal,l), 0.0) * attenuation;\n    }\n    //specular.xyz *= specularLight;\n    //diffuse.xyz *= diffuseLight;\n    color.xyz += ambient.xyz;\n    color.xyz += diffuse.xyz;\n    color.xyz += specular.xyz;\n    color = vec4(color.rgb * diffuse.a, diffuse.a*alpha);\n    gl_FragColor = color;\n    if(picked!=0.0){\n        gl_FragColor =mix(color, pickedColor*0.5,1.0);\n    }\n}";return e});n("Core/Shaders/normals_vert",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\n\n\nvarying vec3 v_position;\nvarying vec3 v_normal;\n\nvarying vec3 v_light0Direction;\n\nvoid main(void) \n{\n    vec4 pos =  modelViewMatrix * vec4( position,1.0);\n    v_normal =  normalMatrix *  normal;\n    v_position = pos.xyz;\n    v_light0Direction = mat3( modelViewMatrix) * vec3(1.0,1.0,1.0);\n    gl_Position =  projectionMatrix * pos;\n}";return e});n("Core/Shaders/texture_frag",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord0;\n\nuniform vec4 ambientColor;\nuniform sampler2D diffuseColorMap;\nuniform vec4 specularColor;\nuniform float specularShininess;\nuniform float picked;\nuniform vec4  pickedColor;\n\nuniform float alpha;\n\nvoid main(void) \n{\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\n    vec3 lightColor = vec3(1.0,1.0,1.0);\n    vec4 ambient = ambientColor;\n    vec4 diffuse = texture2D(diffuseColorMap, v_texcoord0);\n    vec4 specular = specularColor;\n    color.xyz += ambient.xyz;\n    color.xyz += diffuse.xyz;\n    color.xyz += specular.xyz;\n    color = vec4(diffuse.rgb * diffuse.a, diffuse.a*alpha);\n    gl_FragColor = color;\n    if(picked!=0.0){\n        gl_FragColor =mix(color, pickedColor*0.5,1.0);\n    }\n}";return e});n("Core/Shaders/texture_vert",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\n\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord0;\n\nvoid main(void) \n{\n    vec4 pos =  modelViewMatrix * vec4( position,1.0);\n    v_texcoord0 =  uv;\n    v_position = pos.xyz;\n    gl_Position =  projectionMatrix * pos;\n}";return e});n("Core/Shaders/texture_normals_frag",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord0;\nvarying vec3 v_normal;\n\nuniform vec4 ambientColor;\nuniform sampler2D diffuseColorMap;\nuniform vec4 specularColor;\nuniform float specularShininess;\nuniform float picked;\nuniform vec4  pickedColor;\n\nvarying vec3 v_light0Direction;\n\nvoid main(void) \n{\n    vec3 positionToEyeEC = -v_position; \n    vec3 normalEC =normalize(v_normal);\n    vec3 normal = normalize(v_normal);\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\n    vec3 lightColor = vec3(1.0,1.0,1.0);\n    vec4 ambient = ambientColor;\n    vec4 diffuse = texture2D(diffuseColorMap, v_texcoord0);\n    vec4 specular = specularColor;\n\n    vec3 specularLight = vec3(0.0, 0.0, 0.0);\n    {\n        float specularIntensity = 0.0;\n        float attenuation = 1.0;\n        vec3 l = normalize(v_light0Direction);\n        vec3 viewDir = -normalize(v_position);\n        vec3 h = normalize(l+viewDir);\n        specularIntensity = max(0.0, pow(max(dot(normal,h), 0.0) , specularShininess)) * attenuation;\n        specularLight += lightColor * specularIntensity;\n        diffuseLight += lightColor * max(dot(normal,l), 0.0) * attenuation;\n    }\n    //specular.xyz *= specularLight;\n    //diffuse.xyz *= diffuseLight;\n    color.xyz += ambient.xyz;\n    color.xyz += diffuse.xyz;\n    color.xyz += specular.xyz;\n    color = vec4(diffuse.rgb * diffuse.a, diffuse.a);\n    //gl_FragColor = color;\n    if(picked!=0.0){\n        color = pickedColor*color;\n    }\n    czm_material material;\n    material.specular = 0.0;\n    material.shininess = 1.0;\n    material.normal =  normalEC;\n    material.emission =vec3(0.2,0.2,0.2);\n    material.diffuse = color.rgb ;\n    material.alpha =  color.a;\n    gl_FragColor =  czm_phong(normalize(positionToEyeEC), material);\n}";return e});n("Core/Shaders/texture_normals_vert",[],function(){var e="\n#ifdef GL_ES\n    precision highp float;\n#endif\n\n\n\nvarying vec3 v_position;\nvarying vec2 v_texcoord0;\nvarying vec3 v_normal;\n\nvarying vec3 v_light0Direction;\n\nvoid main(void) \n{\n    vec4 pos =  modelViewMatrix * vec4( position,1.0);\n    v_normal =  normalMatrix *  normal;\n    v_texcoord0 =uv;\n    v_position = pos.xyz;\n    v_light0Direction = mat3( modelViewMatrix) * vec3(1.0,1.0,1.0);\n    gl_Position =  projectionMatrix * pos;\n}";return e});n("Core/Shaders/ShaderChunk",["Core/Shaders/none_frag","Core/Shaders/none_vert","Core/Shaders/normals_frag","Core/Shaders/normals_vert","Core/Shaders/texture_frag","Core/Shaders/texture_vert","Core/Shaders/texture_normals_frag","Core/Shaders/texture_normals_vert"],function(e,t,n,i,r,a,o,s){var l="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";var c="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";var f="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";var d="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";var u="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var m="\nvec3 transformed = vec3( position );\n";var p="\nvec3 objectNormal = vec3( normal );\n";var h="float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";var v="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";var g="#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";var _="#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";var x="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";var C="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";var y="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";var M="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";var w="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";var S="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";var L="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";var E="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";var P="vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";var b="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";var T="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";var D="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";var U="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";var N="  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";var A="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";var I="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = asin( flipNormal * reflectVec.y ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";var R="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";var G="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";var z="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";var V="\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";var F="#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";var O="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";var H="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";var B="#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";var k="#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";var Y="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif"
;var X="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";var W="uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";var j="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";var q="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";var Z="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";var Q="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";var K="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";var J="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";var $="#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";var ee="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";var te="#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";var ne="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";var ie="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";var re="#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";var ae="#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";var oe="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";var se="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var le="#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";var ce="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";var fe="#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";var de="#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";var ue="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";var me="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";var pe="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";var he="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";var ve="vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";var ge="#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";var _e="#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";var xe="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";var Ce="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif"
;var ye="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";var Me="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";var we="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";var Se="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";var Le="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var Ee="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";var Pe="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";var be="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";var Te="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var De="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var Ue="#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";var Ne="#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";var Ae="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";var Ie="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";var Re="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";var Ge="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var ze="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";var Ve="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";var Fe="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";var Oe="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";var He="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var Be="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";var ke="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";var Ye="uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";var Xe="varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";var We="uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";var je="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var qe="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var Ze="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";var Qe="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var Ke="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";var Je="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var $e="#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var et="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var tt="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var nt="#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var it="#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var rt="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";var at="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n"
;var ot="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var st="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var lt="uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";var ct="#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";var ft={alphamap_fragment:l,alphamap_pars_fragment:c,alphatest_fragment:f,aomap_fragment:d,aomap_pars_fragment:u,begin_vertex:m,beginnormal_vertex:p,bsdfs:h,bumpmap_pars_fragment:v,clipping_planes_fragment:g,clipping_planes_pars_fragment:_,clipping_planes_pars_vertex:x,clipping_planes_vertex:C,color_fragment:y,color_pars_fragment:M,color_pars_vertex:w,color_vertex:S,common:L,cube_uv_reflection_fragment:E,defaultnormal_vertex:P,displacementmap_pars_vertex:b,displacementmap_vertex:T,emissivemap_fragment:D,emissivemap_pars_fragment:U,encodings_fragment:N,encodings_pars_fragment:A,envmap_fragment:I,envmap_pars_fragment:R,envmap_pars_vertex:G,envmap_vertex:z,fog_vertex:V,fog_pars_vertex:F,fog_fragment:O,fog_pars_fragment:H,gradientmap_pars_fragment:B,lightmap_fragment:k,lightmap_pars_fragment:Y,lights_lambert_vertex:X,lights_pars:W,lights_phong_fragment:j,lights_phong_pars_fragment:q,lights_physical_fragment:Z,lights_physical_pars_fragment:Q,lights_template:K,logdepthbuf_fragment:J,logdepthbuf_pars_fragment:$,logdepthbuf_pars_vertex:ee,logdepthbuf_vertex:te,map_fragment:ne,map_pars_fragment:ie,map_particle_fragment:re,map_particle_pars_fragment:ae,metalnessmap_fragment:oe,metalnessmap_pars_fragment:se,morphnormal_vertex:le,morphtarget_pars_vertex:ce,morphtarget_vertex:fe,normal_flip:de,normal_fragment:ue,normalmap_pars_fragment:me,packing:pe,premultiplied_alpha_fragment:he,project_vertex:ve,dithering_fragment:ge,dithering_pars_fragment:_e,roughnessmap_fragment:xe,roughnessmap_pars_fragment:Ce,shadowmap_pars_fragment:ye,shadowmap_pars_vertex:Me,shadowmap_vertex:we,shadowmask_pars_fragment:Se,skinbase_vertex:Le,skinning_pars_vertex:Ee,skinning_vertex:Pe,skinnormal_vertex:be,specularmap_fragment:Te,specularmap_pars_fragment:De,tonemapping_fragment:Ue,tonemapping_pars_fragment:Ne,uv_pars_fragment:Ae,uv_pars_vertex:Ie,uv_vertex:Re,uv2_pars_fragment:Ge,uv2_pars_vertex:ze,uv2_vertex:Ve,worldpos_vertex:Fe,cube_frag:Oe,cube_vert:He,depth_frag:Be,depth_vert:ke,distanceRGBA_frag:Ye,distanceRGBA_vert:Xe,equirect_frag:We,equirect_vert:je,linedashed_frag:qe,linedashed_vert:Ze,meshbasic_frag:Qe,meshbasic_vert:Ke,meshlambert_frag:Je,meshlambert_vert:$e,meshphong_frag:et,meshphong_vert:tt,meshphysical_frag:nt,meshphysical_vert:it,normal_frag:rt,normal_vert:at,points_frag:ot,points_vert:st,shadow_frag:lt,shadow_vert:ct,none_frag:e,none_vert:t,normals_frag:n,normals_vert:i,texture_frag:r,texture_vert:a,texture_normals_frag:o,texture_normals_vert:s};ft.parseIncludes=function(e){var t=/#include +<([\w\d.]+)>/g;function n(e,t){var n=ft[t];if(n===undefined){throw new Error("Can not resolve #include <"+t+">")}return ft.parseIncludes(n)}return e.replace(t,n)};return ft});n("Core/FramebufferTexture",[],function(){function e(e,t){this.mesh=e;this.texture=null}return e});n("Core/LOD",["Core/Rotation","Core/RendererUtils"],function(e,t){var n=Cesium.defaultValue;function i(t){t=n(t,{});this.uuid=Cesium.createGuid();this.show=n(t.show,true);this.maxAvailableDistance=n(t.maxAvailableDistance,Number.MAX_VALUE);this._position=n(t.position,new Cesium.Cartesian3(0,0,0));this._scale=n(t.scale,new Cesium.Cartesian3(1,1,1));this._rotation=n(t.rotation,{axis:new Cesium.Cartesian3(0,0,1),angle:0});this._rotation=new e(this._rotation.axis,this._rotation.angle);this._boundingSphere=new Cesium.BoundingSphere;this._needsUpdate=false;this._modelMatrixNeedsUpdate=true;this._modelMatrix=new Cesium.Matrix4;Cesium.Matrix4.clone(Cesium.Matrix4.IDENTITY,this._modelMatrix);this._onNeedUpdateChanged=function(){this._modelMatrixNeedsUpdate=true};this._rotation.paramChanged.removeEventListener(this._onNeedUpdateChanged);this._children=[];this._parent=null;this.type="LOD";Object.defineProperties(this,{levels:{enumerable:true,value:[]}})}function r(e,t){for(var n=0;n<e.length;n++){if(e[n]==t){e.splice(n,1);break}}}i.prototype={constructor:i,setPosition:function(e,t,n){var i=false;if(arguments.length==1){if(typeof e=="number"){if(e!=this._position.x)i=true;this._position.x=e}else if(e instanceof Cesium.Cartesian3){if(e!=this._position.x||t!=this._position.y||n!=this._position.z){i=true}this._position.x=e.x;this._position.y=e.y;this._position.z=e.z}}if(arguments.length==2&&typeof t=="number"){if(t!=this._position.y)i=true;this._position.y=t}if(arguments.length==3&&typeof n=="number"){if(n!=this._position.z)i=true;this._position.z=n}if(i){this._modelMatrixNeedsUpdate=true}},setScale:function(e,t,n){var i=false;if(arguments.length==1){if(typeof e=="number"){if(e!=this._scale.x)i=true;this._scale.x=e}else if(e instanceof Cesium.Cartesian3){if(e!=this._scale.x||t!=this._scale.y||n!=this._scale.z){i=true}this._scale.x=e.x;this._scale.y=e.y;this._scale.z=e.z}}if(arguments.length==2&&typeof t=="number"){if(t!=this._scale.y)i=true;this._scale.y=t}if(arguments.length==3&&typeof n=="number"){if(n!=this._scale.z)i=true;this._scale.z=n}if(i){this._modelMatrixNeedsUpdate=true}},addLevel:function(e,t){if(t===undefined)t=0;t=Math.abs(t);var n=this.levels;for(var i=0;i<n.length;i++){if(t<n[i].distance){break}}n.splice(i,0,{distance:t,object:e});e.parent=this;this._children.push(e);if(this.levels[0].object.geometry){this._boundingSphere.radius=this.levels[0].object.geometry.boundingSphere.radius}else if(this.levels[0].object.boundingSphere){this._boundingSphere.radius=this.levels[0].object.boundingSphere.radius}},update:function(){var e=new Cesium.Cartesian3;return function n(i,r){var a=this.levels;if(a.length>1){if(this._modelMatrixNeedsUpdate){t.computeModelMatrix(i,this.position,this.rotation,this.scale,this.modelMatrix);this._modelMatrixNeedsUpdate=false}Cesium.Matrix4.getTranslation(this.modelMatrix,e);Cesium.Cartesian3.clone(e,this._boundingSphere.center);var o=this._boundingSphere;var s=Math.max(0,Cesium.Cartesian3.distance(o.center,r.camera.positionWC)-o.radius);var l=this.maxAvailableDistance>s;l=l&&r.cullingVolume.computeVisibility(this._boundingSphere)!==Cesium.Intersect.OUTSIDE;a[0].object.show=l;for(var c=1,f=a.length;c<f;c++){if(s>=a[c].distance){a[c-1].object.show=false;a[c].object.show=l}else{break}}for(;c<f;c++){a[c].object.show=false}}}}(),getObjectForDistance:function(e){var t=this.levels;for(var n=1,i=t.length;n<i;n++){if(e<t[n].distance){break}}return t[n-1].object}};Cesium.defineProperties(i.prototype,{modelMatrix:{get:function(){return this._modelMatrix}},parent:{get:function(){return this._parent},set:function(e){if(e&&(e._children&&Cesium.isArray(e._children)||e.children&&Cesium.isArray(e.children))){if(this._parent&&this._parent!=e){var t=this._parent._children?this._parent._children:this._parent.children;if(Cesium.isArray(t)){r(t,this)}}this._parent=e;if(typeof this._parent.add==="function"){this._parent.add(this)}else{var t=e._children?e._children:e.children;t.push(this)}}this._needsUpdate=true}},children:{get:function(){return this._children},set:function(e){this._children=e;this._needsUpdate=true}},needsUpdate:{get:function(){return this._needsUpdate},set:function(e){this._needsUpdate=e}},rotation:{get:function(){return this._rotation},set:function(e){if(e!=this._rotation){this._rotation=e;this._needUpdate=true}this._rotation.paramChanged.removeEventListener(this._onNeedUpdateChanged);this._rotation=e;this._rotation.paramChanged.addEventListener(this._onNeedUpdateChanged)}},position:{get:function(){return this._position},set:function(e){if(e.x!=this._position.x||e.y!=this._position.y||e.z!=this._position.z){this._position=e;this._needsUpdate=true}this._position=e}},scale:{get:function(){return this._scale},set:function(e){if(e.x!=this._scale.x||e.y!=this._scale.y||e.z!=this._scale.z){this._scale=e;this._needsUpdate=true}this._scale=e}}});return i});n("Core/ArrowGeometry",["Core/GeometryUtils"],function(e){function t(e){e=Cesium.defaultValue(e,{});this.length=Cesium.defaultValue(e.length,5e4);this.width=Cesium.defaultValue(e.width,125);this.headLength=Cesium.defaultValue(e.headLength,5e3);this.headWidth=Cesium.defaultValue(e.headWidth,1e3);this.reverse=Cesium.defaultValue(e.reverse,false)}t.createGeometry=function(t){var n=t.length;var i=t.width;var r=t.headLength;var a=t.headWidth;var o=t.reverse;var s=Cesium.CylinderGeometry.createGeometry(new Cesium.CylinderGeometry({length:n,topRadius:i,bottomRadius:i}));var l;if(o){l=Cesium.CylinderGeometry.createGeometry(new Cesium.CylinderGeometry({length:r,topRadius:a,bottomRadius:0}));e.translate(l,[0,0,-(n+r)/2])}else{l=Cesium.CylinderGeometry.createGeometry(new Cesium.CylinderGeometry({length:r,topRadius:0,bottomRadius:a}));e.translate(l,[0,0,(n+r)/2])}var c=e.mergeGeometries([s,l]);return c};return t});n("Core/PlaneGeometry",[],function(){function e(e){this.type="PlaneGeometry";if(!e||!e.positions){throw new Error("缺少positions参数")}if(e.positions.length!=4&&e.positions.length/3!=4){throw new Error("positions参数必须包含四个顶点的位置坐标")}this.positions=e.positions}e.createGeometry=function(e){var t=e.positions;var n;if(Cesium.isArray(t)){if(t[0]instanceof Cesium.Cartesian3){n=new Float32Array(12);for(var i=0;i<t.length;i++){var r=t[i];n[i*3]=r.x;n[i*3+1]=r.y;n[i*3+2]=r.z}}else if(typeof t[0]==="number"){n=new Float32Array(n)}else{throw new Error("positions参数有误")}}else{throw new Error("positions参数必须是数组类型")}var a=new Int32Array([0,1,3,1,2,3]);var o={position:new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t})};var s=Cesium.BoundingSphere.fromVertices(t);var l=new Cesium.Geometry({attributes:o,indices:new Int32Array(a),primitiveType:Cesium.PrimitiveType.TRIANGLES,boundingSphere:s});return l};return e});n("Core/ReferenceMesh",["Core/ArrowGeometry","Core/PlaneGeometry","Core/Mesh","Core/MeshMaterial","Core/Rotation","Core/RendererUtils"],function(e,t,n,i,r,a){var o=Cesium.defaultValue;function s(t){t=Cesium.defaultValue(t,{});this._axisParameter=new e(t.axisParameter);this._axisParameterY=new e(t.axisParameter);this._axisParameterY.reverse=true;var a=new i({defaultColor:"rgba(255,0,0,1)",wireframe:false,side:i.Sides.DOUBLE,translucent:false});var s=new i({defaultColor:"rgba(0,255,0,1)",wireframe:false,side:i.Sides.DOUBLE,translucent:true});var l=new i({defaultColor:"rgba(0,0,255,1)",wireframe:false,side:i.Sides.DOUBLE,translucent:false});var c=e.createGeometry(new e(this._axisParameter));var f=e.createGeometry(new e(this._axisParameterY));var d=new n(c,a);var u=new n(f,s);var m=new n(c,l);d.position.z=this._axisParameter.length/2;u.position.y=-this._axisParameter.length/2;u.rotation.axis.y=1;u.rotation.angle=-180;m.position.x=this._axisParameter.length/2;m.rotation.axis.x=1;m.rotation.angle=-180;m.parent=this;u.parent=this;d.parent=this;this._children=[m,u,d];this.x=m;this.y=u;this.z=d;this.uuid=Cesium.createGuid();this.show=o(t.show,true);this._position=o(t.position,new Cesium.Cartesian3(0,0,0));this._scale=o(t.scale,new Cesium.Cartesian3(1,1,1));this._rotation=o(t.rotation,{axis:new Cesium.Cartesian3(0,0,1),angle:0});this._rotation=new r(this._rotation.axis,this._rotation.angle);this._needsUpdate=true;this._modelMatrixNeedsUpdate=true;this._modelMatrix=new Cesium.Matrix4;Cesium.Matrix4.clone(Cesium.Matrix4.IDENTITY,this._modelMatrix);this._onNeedUpdateChanged=function(){this._modelMatrixNeedsUpdate=true};this._rotation.paramChanged.removeEventListener(this._onNeedUpdateChanged);this._parent=null}function l(e,t){for(var n=0;n<e.length;n++){if(e[n]==t){e.splice(n,1);break}}}Cesium.defineProperties(s.prototype,{modelMatrix:{get:function(){return this._modelMatrix}},parent:{get:function(){return this._parent},set:function(e){if(e&&(e._children&&Cesium.isArray(e._children)||e.children&&Cesium.isArray(e.children))){if(this._parent&&this._parent!=e){var t=this._parent._children?this._parent._children:this._parent.children;if(Cesium.isArray(t)){l(t,this)}}this._parent=e;if(typeof this._parent.add==="function"){this._parent.add(this)}else{var t=e._children?e._children:e.children;t.push(this)}}this.modelMatrixNeedsUpdate=true}},modelMatrixNeedsUpdate:{get:function(){return this._modelMatrixNeedsUpdate},set:function(e){this._modelMatrixNeedsUpdate=e;if(this._modelMatrixNeedsUpdate){n.traverse(this,function(t){t._modelMatrixNeedsUpdate=e})}}},children:{get:function(){return this._children}},needsUpdate:{get:function(){return this._needsUpdate},set:function(e){this._needsUpdate=e}},rotation:{get:function(){return this._rotation},set:function(e){if(e!=this._rotation){this._rotation=e;this.modelMatrixNeedsUpdate=true}this._rotation.paramChanged.removeEventListener(this._onNeedUpdateChanged);this._rotation=e;this._rotation.paramChanged.addEventListener(this._onNeedUpdateChanged)}},position:{get:function(){return this._position},set:function(e){if(e.x!=this._position.x||e.y!=this._position.y||e.z!=this._position.z){this._position=e;this.modelMatrixNeedsUpdate=true}this._position=e}},scale:{get:function(){return this._scale},set:function(e){if(e.x!=this._scale.x||e.y!=this._scale.y||e.z!=this._scale.z){this._scale=e;this.modelMatrixNeedsUpdate=true}this._scale=e}}});s.prototype.update=function(e,t){if(this._modelMatrixNeedsUpdate||this._needsUpdate){a.computeModelMatrix(e,this.position,this.rotation,this.scale,this.modelMatrix);this._modelMatrixNeedsUpdate=false}};return s});function i(){this.tiffDataView=undefined;this.littleEndian=undefined;this.fileDirectories=[]}i.prototype={isLittleEndian:function(){var e=this.getBytes(2,0);if(e===18761){this.littleEndian=true}else if(e===19789){this.littleEndian=false}else{console.log(e);throw TypeError("Invalid byte order value.")}return this.littleEndian},hasTowel:function(){if(this.getBytes(2,2)!==42){throw RangeError("You forgot your towel!");return false}return true},getFieldTagName:function(e){var t={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop"};var n;if(e in t){n=t[e]}else{n="Tag"+e}return n},getFieldTypeName:function(e){var t={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE"};var n;if(e in t){n=t[e]}return n},getFieldTypeLength:function(e){var t;if(["BYTE","ASCII","SBYTE","UNDEFINED"].indexOf(e)!==-1){t=1}else if(["SHORT","SSHORT"].indexOf(e)!==-1){t=2}else if(["LONG","SLONG","FLOAT"].indexOf(e)!==-1){t=4}else if(["RATIONAL","SRATIONAL","DOUBLE"].indexOf(e)!==-1){t=8}return t},getBits:function(e,t,n){n=n||0;var i=Math.floor(n/8);var r=t+i;var a=n+e;var o=32-e;if(a<=0){console.log(e,t,n);throw RangeError("No bits requested")}else if(a<=8){var s=24+n;var l=this.tiffDataView.getUint8(r,this.littleEndian)}else if(a<=16){var s=16+n;var l=this.tiffDataView.getUint16(r,this.littleEndian)}else if(a<=32){var s=n;var l=this.tiffDataView.getUint32(r,this.littleEndian)}else{console.log(e,t,n);throw RangeError("Too many bits requested")}var c={bits:l<<s>>>o,byteOffset:r+Math.floor(a/8),bitOffset:a%8};return c},getBytes:function(e,t){if(e<=0){console.log(e,t);throw RangeError("No bytes requested")}else if(e<=1){return this.tiffDataView.getUint8(t,this.littleEndian)}else if(e<=2){return this.tiffDataView.getUint16(t,this.littleEndian)}else if(e<=3){return this.tiffDataView.getUint32(t,this.littleEndian)>>>8}else if(e<=4){return this.tiffDataView.getUint32(t,this.littleEndian)}else{console.log(e,t);throw RangeError("Too many bytes requested")}},getFieldValues:function(e,t,n,i){var r=[];var a=this.getFieldTypeLength(t);var o=a*n;if(o<=4){if(this.littleEndian===false){var s=i>>>(4-a)*8}else{var s=i}r.push(s)}else{for(var l=0;l<n;l++){var c=a*l;if(a>=8){if(["RATIONAL","SRATIONAL"].indexOf(t)!==-1){r.push(this.getBytes(4,i+c));r.push(this.getBytes(4,i+c+4))}else{console.log(t,n,o);throw TypeError("Can't handle this field type or size")}}else{r.push(this.getBytes(a,i+c))}}}if(t==="ASCII"){r.forEach(function(e,t,n){n[t]=String.fromCharCode(e)})}return r},clampColorSample:function(e,t){var n=Math.pow(2,8-t);return Math.floor(e*n+(n-1))},makeRGBAFillValue:function(e,t,n,i){if(typeof i==="undefined"){i=1}return"rgba("+e+", "+t+", "+n+", "+i+")"},parseFileDirectory:function(e){var t=this.getBytes(2,e);var n=[];for(var i=e+2,r=0;r<t;i+=12,r++){var a=this.getBytes(2,i);var o=this.getBytes(2,i+2);var s=this.getBytes(4,i+4);var l=this.getBytes(4,i+8);var c=this.getFieldTagName(a);var f=this.getFieldTypeName(o);var d=this.getFieldValues(c,f,s,l);n[c]={type:f,values:d}}this.fileDirectories.push(n);var u=this.getBytes(4,i);if(u===0){return this.fileDirectories}else{return this.parseFileDirectory(u)}},parseTIFF:function(e,t){t=t||document.createElement("canvas");this.tiffDataView=new DataView(e);this.canvas=t;this.littleEndian=this.isLittleEndian(this.tiffDataView);if(!this.hasTowel(this.tiffDataView,this.littleEndian)){return}var n=this.getBytes(4,4);this.fileDirectories=this.parseFileDirectory(n);var i=this.fileDirectories[0];var r=i.ImageWidth.values[0];var a=i.ImageLength.values[0];this.canvas.width=r;this.canvas.height=a;var o=[];var s=i.Compression?i.Compression.values[0]:1;var l=i.SamplesPerPixel.values[0];var c=[];var f=0;var d=false;i.BitsPerSample.values.forEach(function(e,t,n){c[t]={bitsPerSample:e,hasBytesPerSample:false,bytesPerSample:undefined};if(e%8===0){c[t].hasBytesPerSample=true;c[t].bytesPerSample=e/8}f+=e},this);if(f%8===0){d=true;var u=f/8}var m=i.StripOffsets.values;var p=m.length;if(i.StripByteCounts){var h=i.StripByteCounts.values}else{console.log("Missing StripByteCounts!");if(p===1){var h=[Math.ceil(r*a*f/8)]}else{throw Error("Cannot recover from missing StripByteCounts")}}for(var v=0;v<p;v++){var g=m[v];o[v]=[];var _=h[v];for(var x=0,C=0,y=1,M=true,w=[],S=0,L=0,E=0;x<_;x+=y){switch(s){case 1:for(var P=0,w=[];P<l;P++){if(c[P].hasBytesPerSample){var b=c[P].bytesPerSample*P;w.push(this.getBytes(c[P].bytesPerSample,g+x+b))}else{var T=this.getBits(c[P].bitsPerSample,g+x,C);w.push(T.bits);x=T.byteOffset-g;C=T.bitOffset;throw RangeError("Cannot handle sub-byte bits per sample")}}o[v].push(w);if(d){y=u}else{y=0;throw RangeError("Cannot handle sub-byte bits per pixel")}break;case 2:break;case 3:break;case 4:break;case 5:break;case 6:break;case 7:break;case 32773:if(M){M=false;var D=1;var U=1;var N=this.tiffDataView.getInt8(g+x,this.littleEndian);if(N>=0&&N<=127){D=N+1}else if(N>=-127&&N<=-1){U=-N+1}else{M=true}}else{var A=this.getBytes(1,g+x);for(var P=0;P<U;P++){if(c[L].hasBytesPerSample){E=E<<8*S|A;S++;if(S===c[L].bytesPerSample){w.push(E);E=S=0;L++}}else{throw RangeError("Cannot handle sub-byte bits per sample")}if(L===l){o[v].push(w);w=[];L=0}}D--;if(D===0){M=true}}y=1;break;default:break}}}if(t.getContext){var I=this.canvas.getContext("2d");I.fillStyle=this.makeRGBAFillValue(255,255,255,0);if(i.RowsPerStrip){var R=i.RowsPerStrip.values[0]}else{var R=a}var G=o.length;var z=a%R;var V=z===0?R:z;var F=R;var O=0;var H=i.PhotometricInterpretation.values[0];var B=[];var k=0;if(i.ExtraSamples){B=i.ExtraSamples.values;k=B.length}if(i.ColorMap){var Y=i.ColorMap.values;var X=Math.pow(2,c[0].bitsPerSample)}for(var v=0;v<G;v++){if(v+1===G){F=V}var W=o[v].length;var j=O*v;for(var q=0,Z=0;q<F,Z<W;q++){for(var Q=0;Q<r;Q++,Z++){var K=o[v][Z];var J=0;var $=0;var ee=0;var te=1;if(k>0){for(var ne=0;ne<k;ne++){if(B[ne]===1||B[ne]===2){te=K[3+ne]/256;break}}}switch(H){case 0:if(c[0].hasBytesPerSample){var ie=Math.pow(16,c[0].bytesPerSample*2)}K.forEach(function(e,t,n){n[t]=ie-e});case 1:J=$=ee=this.clampColorSample(K[0],c[0].bitsPerSample);break;case 2:J=this.clampColorSample(K[0],c[0].bitsPerSample);$=this.clampColorSample(K[1],c[1].bitsPerSample);ee=this.clampColorSample(K[2],c[2].bitsPerSample);break;case 3:if(Y===undefined){throw Error("Palette image missing color map")}var re=K[0];J=this.clampColorSample(Y[re],16);$=this.clampColorSample(Y[X+re],16);ee=this.clampColorSample(Y[2*X+re],16);break;case 4:throw RangeError("Not Yet Implemented: Transparency mask");break;case 5:throw RangeError("Not Yet Implemented: CMYK");break;case 6:throw RangeError("Not Yet Implemented: YCbCr");break;case 8:throw RangeError("Not Yet Implemented: CIELab");break;default:throw RangeError("Unknown Photometric Interpretation:",H);break}I.fillStyle=this.makeRGBAFillValue(J,$,ee,te);I.fillRect(Q,j+q,1,1)}}O=F}}return this.canvas}};if(typeof module==="undefined"){this.TIFFParser=i}else{module.exports=i}if(typeof n==="function"){n("ThirdParty/tiff-js/tiff",[],function(){return i})}function r(){}r.GetExtension=function(e){var t=e.lastIndexOf(".");if(t>=0){return e.substring(t,e.length)}return""};r.GetFileName=function(e){var t=e.lastIndexOf("/");if(t<0){return e}return e.substring(t+1,e.length)};r.GetDirectoryName=function(e){var t=e.lastIndexOf("/");if(t<0){return""}return e.substring(0,t)};r.Combine=function(e,t){return e+t};r.ChangeExtension=function(e,t){return e.replace(r.GetExtension(e),t)};if(typeof module==="undefined"){this.Path=r}else{module.exports=r}if(typeof n==="function"){n("Util/Path",[],function(){return r})}n("Core/MeshVisualizer",["Core/Mesh","Core/RendererUtils","Core/MeshMaterial","Core/Shaders/ShaderChunk","Core/Rotation","Core/FramebufferTexture","Core/LOD","Core/ReferenceMesh","ThirdParty/tiff-js/tiff","Util/Path","Core/GeometryUtils"],function(e,t,n,i,r,a,o,s,l,c,f){var d=Cesium.Matrix4;var u=Cesium.DrawCommand;var m=Cesium.defined;var p=Cesium.GeometryPipeline;var h=Cesium.BufferUsage;var v=Cesium.BlendingState;var g=Cesium.VertexArray;var _=Cesium.ShaderProgram;var x=Cesium.DepthFunction;var C=Cesium.CullFace;var y=Cesium.RenderState;var M=Cesium.defaultValue;var w=Cesium.Texture;var S=Cesium.PixelFormat;var L=Cesium.BoxGeometry;var E=Cesium.Cartesian3;var P=Cesium.VertexFormat;var b=Cesium.CubeMap;var T=Cesium.loadCubeMap;var D=Cesium.Matrix3;var U=Cesium.Math;var N=Cesium.Color;var A=new E;var I=new Cesium.Quaternion;var R=new E;var G=new d;var z=new d;var V=new E;var F={cancelCurrent:false};Cesium.Cartesian3.prototype.set=function(e,t,n){this.x=e;this.y=t;this.z=n};Cesium.Cartesian3.prototype.copy=function(e){this.x=e.x;this.y=e.y;this.z=e.z};Cesium.Cartesian2.prototype.set=function(e,t){this.x=e;this.y=t};Cesium.Cartesian2.prototype.copy=function(e){this.x=e.x;this.y=e.y};Cesium.Quaternion.prototype.set=function(e,t,n,i){this.x=e;this.y=t;this.z=n;this.w=i};Cesium.Quaternion.prototype.copy=function(e){this.x=e.x;this.y=e.y;this.z=e.z;this.w=e.w};function O(e){this._modelMatrix=M(e.modelMatrix,d.IDENTITY);this._actualModelMatrix=d.clone(this._modelMatrix);this._ready=true;this._modelMatrixNeedsUpdate=true;this._isWireframe=false;this._up=M(e.up,new E(0,0,1));this._position=M(e.position,new E(0,0,0));this._scale=M(e.scale,new E(1,1,1));this._rotation=M(e.rotation,{axis:new E(0,0,1),angle:0});this._rotation=new r(this._rotation.axis,this._rotation.angle);this._rotation.paramChanged.addEventListener(this.onModelMatrixNeedUpdate,this);this._chidren=[];this._debug=false;this._show=M(e.show,true);this._center=new E;Cesium.Matrix4.getTranslation(this._modelMatrix,this._center);this._framebufferTextures={};this._uniformValueCache={};this._textureCache={};this._uniformMaps={};this.referenceMesh=new s({axisParameter:M(e.referenceAxisParameter,{length:5e4*2}),show:M(e.showReference,false)});this.add(this.referenceMesh);this._pickIds=[];this.beforeUpate=new Cesium.Event;this._scene=null}var H=new Cesium.Matrix4;var B=new Cesium.Cartesian3;var k=new Cesium.Cartesian3;var Y=new Cesium.Cartesian3;var X=new Cesium.Cartesian3;var W=new Cesium.Ray;O.prototype={remove:function(e){for(var t=0;t<this._chidren.length;t++){if(this._chidren[t]==e){this._chidren.splice(t,1)}}O.traverse(e,function(){if(e._drawCommand){e._drawCommand.destroy&&e._drawCommand.destroy()}if(e._actualMesh&&e._actualMesh._drawCommand){Cesium.destroyObject(e._actualMesh._drawCommand);Cesium.destroyObject(e._actualMesh.geometry);Cesium.destroyObject(e._actualMesh);Cesium.destroyObject(e)}},false)},pickPosition:function(e,t){if(!this._scene){return undefined}this._scene.pickPosition(e,B);if(!B){return undefined}this.worldCoordinatesToLocal(B,B);Cesium.Cartesian3.clone(B,t);return t},getPickRay:function(e,t){if(!this._scene){return undefined}if(!t){t=Cesium.Ray()}this._scene.camera.getPickRay(e,W);this._scene.pickPosition(e,B);if(!B){return undefined}Cesium.Cartesian3.clone(W.direction,k);this.worldCoordinatesToLocal(W.origin,X);this.worldCoordinatesToLocal(B,B);Cesium.Cartesian3.add(X,k,Y);Cesium.Cartesian3.subtract(B,Y,k);Cesium.Cartesian3.clone(B,t.origin);Cesium.Cartesian3.clone(k,t.direction);return t},worldCoordinatesToLocal:function(e,t){if(!t){t=new E}Cesium.Matrix4.inverseTransformation(this._actualModelMatrix,H);Cesium.Matrix4.multiplyByPoint(H,e,t);return t},localToWorldCoordinates:function(e,t){if(!t){t=new E}Cesium.Matrix4.multiplyByPoint(this._actualModelMatrix,e,t);return t},onModelMatrixNeedUpdate:function(){this._modelMatrixNeedsUpdate=true},setPosition:function(e,t,n){var i=false;if(arguments.length==1){if(typeof e=="number"){if(e!=this._position.x)i=true;this._position.x=e}else if(e instanceof Cesium.Cartesian3){if(e!=this._position.x||t!=this._position.y||n!=this._position.z){i=true}this._position.x=e.x;this._position.y=e.y;this._position.z=e.z}}if(arguments.length==2&&typeof t=="number"){if(t!=this._position.y)i=true;this._position.y=t}if(arguments.length==3&&typeof n=="number"){if(n!=this._position.z)i=true;this._position.z=n}if(i){this._modelMatrixNeedsUpdate=true}},setScale:function(e,t,n){var i=false;if(arguments.length==1){if(typeof e=="number"){if(e!=this._scale.x)i=true;this._scale.x=e}else if(e instanceof Cesium.Cartesian3){if(e!=this._scale.x||t!=this._scale.y||n!=this._scale.z){i=true}this._scale.x=e.x;this._scale.y=e.y;this._scale.z=e.z}}if(arguments.length==2&&typeof t=="number"){if(t!=this._scale.y)i=true;this._scale.y=t}if(arguments.length==3&&typeof n=="number"){if(n!=this._scale.z)i=true;this._scale.z=n}if(i){this._modelMatrixNeedsUpdate=true}},toWireframe:function(e){if(e.primitiveType!==Cesium.PrimitiveType.TRIANGLES&&e.primitiveType!==Cesium.PrimitiveType.TRIANGLE_FAN&&e.primitiveType!==Cesium.PrimitiveType.TRIANGLE_STRIP){return e}if(!e.triangleIndices){e.triangleIndices=e.indices}e=p.toWireframe(e);return e},restoreFromWireframe:function(e){if(e.triangleIndices){e.indices=e.triangleIndices}e.primitiveType=Cesium.PrimitiveType.TRIANGLES;return e},createDrawCommand:function(e,t){var n=this;var i=t.context;var r=e.geometry;var a=e.material;var o=new Cesium.DrawCommand({modelMatrix:d.clone(this.modelMatrix),owner:e,primitiveType:r.primitiveType,cull:false,pass:a.translucent?Cesium.Pass.TRANSLUCENT:Cesium.Pass.OPAQUE});var s=p.createAttributeLocations(r);o.vertexArray=g.fromGeometry({context:i,geometry:r,attributeLocations:s,bufferUsage:h.STATIC_DRAW});o.vertexArray._attributeLocations=s;var l={primitive:this,id:e};var c=i.createPickId(l);n._pickIds.push(c);var f=c.color;o._sp=_.fromCache({context:i,fragmentShaderSource:this.getFragmentShaderSource(a),vertexShaderSource:this.getVertexShaderSource(r,a),attributeLocations:s});o._pickSp=_.fromCache({context:i,fragmentShaderSource:"void main() {\n\tgl_FragColor = vec4("+f.red+","+f.green+","+f.blue+","+f.alpha+");\n}",vertexShaderSource:this.getVertexShaderSource(r,a),attributeLocations:s});o.shaderProgram=o._sp;o.renderState=this.getRenderState(a);o.uniformMap=this.getUniformMap(a,t);return o},getRenderState:function(e){var t={blending:e.blending?v.ALPHA_BLEND:v.DISABLED,depthTest:{enabled:e.depthTest,func:x.LESS},cull:{enabled:true,face:C.FRONT},depthRange:{near:0,far:1},colorMask:{red:true,green:true,blue:true,alpha:true},depthMask:e.depthMask};t.cull.enabled=true;t.blending.color={red:0,green:0,blue:0,alpha:0};switch(e.side){case n.Sides.FRONT:t.cull.face=C.BACK;break;case n.Sides.BACK:t.cull.face=C.FRONT;break;default:t.cull.enabled=false;break}t=y.fromCache(t);return t},getUniformMap:function(e,t){if(this._uniformMaps[e.uuid]&&!e.needsUpdate){return this._uniformMaps[e.uuid]}var n={};this._uniformMaps[e.uuid]=n;e.needsUpdate=false;n.cameraPosition=function(){return t.camera.position};n.u_cameraPosition=function(){return t.camera.position};n.u_normalMatrix=function(){return t.context.uniformState.normal};n.u_projectionMatrix=function(){return t.context.uniformState.projection};n.u_modelViewMatrix=function(){return t.context.uniformState.modelView};n.normalMatrix=function(){return t.context.uniformState.normal};n.projectionMatrix=function(){return t.context.uniformState.projection};n.modelViewMatrix=function(){return t.context.uniformState.modelView};n.modelMatrix=function(){return t.context.uniformState.model};n.u_modelMatrix=function(){
return t.context.uniformState.model};n.u_viewMatrix=function(){return t.context.uniformState.view};n.viewMatrix=function(){return t.context.uniformState.view};if(e.uniformStateUsed&&e.uniformStateUsed.length){e.uniformStateUsed.forEach(function(e){if(!n[e.glslVarName]){if(!t.context.uniformState[e.uniformStateName]){throw new Error(e.uniformStateName+"不是Cesium引擎的内置对象")}n[e.glslVarName]=function(){return t.context.uniformState[e.uniformStateName]}}})}var i=this;function r(e,n,r){var a=function(){if(!i._textureCache[n.uuid]||n.needsUpdate){if(!a.allLoaded&&!a.isLoading){var r=[];for(var o=0;o<n.value.length;o++){if(n.value[o]instanceof HTMLCanvasElement||n.value[o]instanceof HTMLVideoElement||n.value[o]instanceof HTMLImageElement){var s=Cesium.when.defer();requestAnimationFrame(function(){s.resolve(n.value[o])});r.push(s)}else if(typeof n.value[o]==="string"){r.push(Cesium.loadImage(n.value[o]))}else{throw Error(e+""+o+"给定值“ "+n[o]+"” 不是有效的纹理图片")}}a.isLoading=true;n.needsUpdate=false;Cesium.when.all(r,function(e){i._textureCache[n.uuid]=new Cesium.CubeMap({context:t.context,source:{positiveX:e[0],negativeX:e[1],positiveY:e[2],negativeY:e[3],positiveZ:e[4],negativeZ:e[5]}});a.allLoaded=true;a.isLoading=false})}}if(a.allLoaded){return i._textureCache[n.uuid]}else{if(!i.defaultCubeMap){if(!i.defaultTextureImage){i.defaultTextureImage=document.createElement("canvas");i.defaultTextureImage.width=1;i.defaultTextureImage.height=1}i.defaultCubeMap=new Cesium.CubeMap({context:t.context,source:{positiveX:i.defaultTextureImage,negativeX:i.defaultTextureImage,positiveY:i.defaultTextureImage,negativeY:i.defaultTextureImage,positiveZ:i.defaultTextureImage,negativeZ:i.defaultTextureImage}})}return i.defaultCubeMap}};if(a.allLoaded){a.allLoaded=false;a.isLoading=false}return a}function o(e,t){var n=Cesium.TextureMinificationFilter;var i=Cesium.TextureWrap;var r=e.sampler;var a=r.minificationFilter===n.NEAREST_MIPMAP_NEAREST||r.minificationFilter===n.NEAREST_MIPMAP_LINEAR||r.minificationFilter===n.LINEAR_MIPMAP_NEAREST||r.minificationFilter===n.LINEAR_MIPMAP_LINEAR;var o=a||r.wrapS===i.REPEAT||r.wrapS===i.MIRRORED_REPEAT||r.wrapT===i.REPEAT||r.wrapT===i.MIRRORED_REPEAT;var l=e.source;var c=!U.isPowerOfTwo(l.width)||!U.isPowerOfTwo(l.height);if(o&&c){var f=document.createElement("canvas");f.width=U.nextPowerOfTwo(l.width);f.height=U.nextPowerOfTwo(l.height);var d=f.getContext("2d");d.drawImage(l,0,0,l.width,l.height,0,0,f.width,f.height);l=f}var u;if(e.target===s.TEXTURE_2D){u=new w({context:t,source:l,width:e.width,height:e.height,pixelFormat:e.internalFormat,pixelDatatype:e.type,sampler:r,flipY:e.flipY})}if(a){u.generateMipmap()}return u}var s=Cesium.WebGLConstants;function f(e,n){var i;if(m(e.internalFormat)){i=new w({context:t.context,pixelFormat:e.internalFormat,width:e.width,height:e.height,source:{arrayBufferView:e.bufferView},flipY:n.flipY})}else{var r=Cesium.WebGLConstants.RGB;if(e instanceof HTMLCanvasElement||e instanceof HTMLVideoElement||e.src&&e.src.toLocaleLowerCase().indexOf(".png")>=0){r=Cesium.WebGLConstants.RGBA}if(n.sampler){i=o({context:t.context,source:e,target:s.TEXTURE_2D,width:n.width,height:n.height,pixelFormat:r,flipY:n.flipY,sampler:new Cesium.Sampler(n.sampler)},t.context)}else{i=new w({context:t.context,source:e,target:s.TEXTURE_2D,width:n.width,height:n.height,pixelFormat:r,flipY:n.flipY})}}return i}function d(e){var n=function(){if(!i._textureCache[e.value]||e.needsUpdate){if(e.value instanceof HTMLImageElement||e.value instanceof HTMLCanvasElement||e.value instanceof HTMLVideoElement){var r=e.value;i._textureCache[e.value]=f(r,e);e.needsUpdate=false;return i._textureCache[e.value]}else{if(typeof e.value==="string"&&!n.isLoading){n.isLoading=true;e.needsUpdate=false;var a=e.value.toLocaleLowerCase();var o=c.GetExtension(a).slice(1);if(o=="tif"){Cesium.loadArrayBuffer(a).then(function(t){var r=new l;var a=r.parseTIFF(t);if(i._textureCache[e.value]){i._textureCache[e.value].destroy&&i._textureCache[e.value].destroy()}i._textureCache[e.value]=f(a,e);n.isLoading=false}).otherwise(function(e){console.log(e)})}else{Cesium.loadImage(e.value).then(function(t){if(i._textureCache[e.value]){i._textureCache[e.value].destroy&&i._textureCache[e.value].destroy()}i._textureCache[e.value]=f(t,e);n.isLoading=false}).otherwise(function(e){console.log(e)})}}if(!i.defaultTextureImage){i.defaultTextureImage=document.createElement("canvas");i.defaultTextureImage.width=1;i.defaultTextureImage.height=1}if(!i.defaultTexture){i.defaultTexture=new w({context:t.context,source:i.defaultTextureImage})}return i.defaultTexture}}else{return i._textureCache[e.value]}};return n}if(e.uniforms){function u(o,s){if(s!==undefined&&s!==null){var l=typeof s.value==="string";var c=typeof s.value==="string";if(typeof s.value==="string"){var f=s.value.toLocaleLowerCase();if(f.endsWith(".png")||f.endsWith(".jpg")||f.endsWith(".bmp")||f.endsWith(".gif")||f.endsWith(".tif")||f.endsWith(".tiff")||f.startsWith("data:")){l=true;c=false}else{try{Cesium.Color.fromCssColorString(s.value);l=true;c=false}catch(e){l=false;c=false}}}if(s.value instanceof Cesium.Cartesian2||s.value instanceof Cesium.Cartesian3||s.value instanceof Cesium.Cartesian4||s.value instanceof Cesium.Color||s.value instanceof Cesium.Matrix4||s.value instanceof Cesium.Matrix3||s.value instanceof Cesium.Matrix2||typeof s.value==="number"||c){if(!i._uniformValueCache){i._uniformValueCache={}}i._uniformValueCache[s.uuid]=s;if(c){s.value=Cesium.Color.fromCssColorString(s.value)}n[o]=function(){return i._uniformValueCache[s.uuid].value}}else if(s.value instanceof Array&&s.value.length==6){n[o]=r(o,s)}else if(l||s.value instanceof HTMLImageElement||s.value instanceof HTMLCanvasElement||s.value instanceof HTMLVideoElement){n[o]=d(s,e)}else if(s.value instanceof a){if(!i._renderToTextureCommands){i._renderToTextureCommands=[]}if(!i._framebufferTextures[s.uuid]){i._framebufferTextures[s.uuid]=s}n[o]=function(){if(!i._framebufferTextures[s.uuid]||!i._framebufferTextures[s.uuid].value.texture){return t.context.defaultTexture}return i._framebufferTextures[s.uuid].value.texture}}}}var p=e.uniforms;for(var h in p){if(p.hasOwnProperty(h)){var v=p[h];if(v==undefined||v==null){continue}u(h,v)}}}return this._uniformMaps[e.uuid]},getVertexShaderSource:function(e,t){function n(t){var n="";var i=e.attributes;for(var r in i){if(i.hasOwnProperty(r)){var a=i[r];if(a){var o=null;switch(a.componentsPerAttribute){case 1:o="float";break;case 2:o="vec2";break;case 3:o="vec3";break;case 4:o="vec4";break;default:}if(o){if(t.indexOf("attribute "+o+" "+r)>=0){continue}n+="attribute "+o+" "+r+";\n"}}}}return n}var r="\n        uniform mat4 modelViewMatrix;\n        uniform mat4 viewMatrix;\n        uniform mat4 modelMatrix;\n        uniform mat4 projectionMatrix;\n        uniform mat3 normalMatrix;\n        uniform mat4 u_modelViewMatrix;\n        uniform mat4 u_viewMatrix;\n        uniform mat4 u_modelMatrix;\n        uniform mat4 u_projectionMatrix;\n        uniform mat3 u_normalMatrix;\n        uniform vec3 cameraPosition;\n        uniform vec3 u_cameraPosition;\n";var a=["uniform mat4 modelViewMatrix","uniform mat4 modelMatrix","uniform mat4 projectionMatrix","uniform mat3 normalMatrix","uniform mat4 u_modelViewMatrix","uniform mat4 u_modelMatrix","uniform mat4 u_projectionMatrix","uniform mat3 u_normalMatrix","uniform mat4 u_viewMatrix","uniform mat4 viewMatrix","uniform vec3 cameraPosition","uniform vec3 u_cameraPosition"];if(t.vertexShader){r="";a.forEach(function(e){if(t.vertexShader.indexOf(e)<0){r+=e+";\n"}});var o=n(t.vertexShader)+r+t.vertexShader;o=i.parseIncludes(o);return o}else{throw new Error("material.vertexShader 是必须参数")}},getFragmentShaderSource:function(e){if(e.fragmentShader){var t=i.parseIncludes(e.fragmentShader);return t}else{throw new Error("material.fragmentShader 是必须参数")}}};O.prototype._computeModelMatrix=function(e,n){if(e._actualMesh){e=e._actualMesh}var i=this;if(e instanceof o||e instanceof s||typeof e.update==="function"){if(e.parent){if(e.parent==i){e.update(i._actualModelMatrix,n)}else if(e.parent.modelMatrix){e.update(e.parent.modelMatrix,n)}else{e.update(i._actualModelMatrix,n)}}else{e.update(i._actualModelMatrix,n)}}else{var r=e.position;if(e.parent instanceof o){d.clone(e.parent.modelMatrix,e.modelMatrix)}else if(e._modelMatrixNeedsUpdate){var a=e.quaternion?e.quaternion:e.rotation;if(e.parent&&e.parent.modelMatrix){var l=e.parent.modelMatrix?e.parent.modelMatrix:e._drawCommand.modelMatrix;t.computeModelMatrix(l,e.position,a,e.scale,e.modelMatrix)}else{t.computeModelMatrix(i._actualModelMatrix,e.position,a,e.scale,e.modelMatrix)}e._modelMatrixNeedsUpdate=false}}};O.prototype.update=function(n){if(!this._scene){this._scene=n.camera._scene}if(!this._ready||!this.show&&this._chidren.length>0){return}this.beforeUpate.raiseEvent(n);var i=this;var r=false;var o=n.camera._scene._globe._surface.tileProvider._debug.wireframe;if(this.debug){o=true}if(o!=this._isWireframe){r=true}if(this._modelMatrixNeedsUpdate){this._actualModelMatrix=t.computeModelMatrix(this._modelMatrix,this._position,this._rotation,this._scale,this._actualModelMatrix);if(this._up&&this._up.y){this._actualModelMatrix=t.yUp2Zup(this._actualModelMatrix,this._actualModelMatrix)}Cesium.Cartesian3.clone(this._scale,this._oldScale);Cesium.Cartesian3.clone(this._position,this._oldPosition);this._modelMatrixNeedsUpdate=false}O.traverse(this,function(t){if(typeof THREE!=="undefined"&&t instanceof THREE.Mesh){var a=!t._actualMesh||t.needsUpdate||t.geometry.needsUpdate;if(!a){for(var s in t.geometry.attributes){if(t.geometry.attributes.hasOwnProperty(s)){if(t.geometry.attributes[s].needsUpdate){a=true;break}}}}if(a){t._actualMesh=new e(t.geometry,t.material)}t._actualMesh.quaternion=Cesium.Quaternion.clone(t.quaternion);t._actualMesh.position=t.position;t._actualMesh.scale=t.scale;t._actualMesh.modelMatrixNeedsUpdate=t.modelMatrixNeedsUpdate;t=t._actualMesh}i._computeModelMatrix(t,n);if(typeof t.update!=="function"){if(!t._drawCommand||t.needsUpdate||t.geometry.needsUpdate||r){if(o||t.material.wireframe){i.toWireframe(t.geometry)}else{i.restoreFromWireframe(t.geometry)}t._drawCommand=i.createDrawCommand(t,n);t.needsUpdate=false;t.geometry.needsUpdate=false}else{for(var l in t.geometry.attributes){if(t.geometry.attributes.hasOwnProperty(l)){if(t.geometry.attributes[l]&&t.geometry.attributes[l].needsUpdate){var c=t._drawCommand.vertexArray._attributeLocations[l];var f=t._drawCommand.vertexArray._attributes[c].vertexBuffer;f.copyFromArrayView(t.geometry.attributes[l].values,0)}}}if(t.geometry.indexNeedsUpdate){var f=t._drawCommand.vertexArray.indexBuffer;f.copyFromArrayView(t.geometry.indices,0)}}t._drawCommand.modelMatrix=t.modelMatrix;if(!t._drawCommand.boundingVolume){if(!t.geometry.boundingSphere){t.geometry.boundingSphere=Cesium.BoundingSphere.fromVertices(t.geometry.attributes.position.values)}t._drawCommand.boundingVolume=Cesium.BoundingSphere.clone(t.geometry.boundingSphere)}Cesium.Matrix4.getTranslation(t.modelMatrix,t._drawCommand.boundingVolume.center);if(n.passes.pick){t._drawCommand.shaderProgram=t._drawCommand._pickSp}else{t._drawCommand.renderState.depthTest.enabled=true;t._drawCommand.shaderProgram=t._drawCommand._sp}n.commandList.push(t._drawCommand)}else{t.needsUpdate=false}},true);for(var s in i._framebufferTextures){if(i._framebufferTextures.hasOwnProperty(s)){var l=i._framebufferTextures[s].value;if(l instanceof a){l.drawCommands=[];O.traverse(l.mesh,function(t){if(typeof THREE!=="undefined"&&t instanceof THREE.Mesh){var r=!t._actualMesh||t.needsUpdate||t.geometry.needsUpdate;if(!r){for(var a in t.geometry.attributes){if(t.geometry.attributes.hasOwnProperty(a)){if(t.geometry.attributes[a].needsUpdate){r=true;break}}}}if(r){t._actualMesh=new e(t.geometry,t.material)}t._actualMesh.quaternion=Cesium.Quaternion.clone(t.quaternion);t._actualMesh.position=t.position;t._actualMesh.scale=t.scale;t._actualMesh.modelMatrixNeedsUpdate=t.modelMatrixNeedsUpdate;t=t._actualMesh}i._computeModelMatrix(t,n);if(!t._textureCommand||t.needsUpdate||t.geometry.needsUpdate){if(t.material.wireframe){i.toWireframe(t.geometry)}else{i.restoreFromWireframe(t.geometry)}t._textureCommand=i.createDrawCommand(t,n);t.needsUpdate=false;t.material.needsUpdate=false;t._textureCommand.renderState.depthTest.enabled=false}else{for(var o in t.geometry.attributes){if(t.geometry.attributes.hasOwnProperty(o)&&t.geometry.attributes[o]){if(t.geometry.attributes[o]&&t.geometry.attributes[o].needsUpdate){var s=t._textureCommand.vertexArray._attributeLocations[o];var c=t._textureCommand.vertexArray._attributes[s].vertexBuffer;c.copyFromArrayView(t.geometry.attributes[o].values,0)}}}if(t.geometry.indexNeedsUpdate){var c=t._textureCommand.vertexArray.indexBuffer;c.copyFromArrayView(t.geometry.indices,0)}}t._textureCommand.modelMatrix=t.modelMatrix;var f=n.context;var d=f.drawingBufferWidth;var u=f.drawingBufferHeight;if(!l.texture||l.texture.width!=d||l.texture.height!=u){l.texture=new w({context:f,width:d,height:u,pixelFormat:S.RGBA})}l.drawCommands.push(t._textureCommand)},true);t.renderToTexture(l.drawCommands,n,l.texture)}}}this._isWireframe=o;r=false;this._modelMatrixNeedsUpdate=false;this._geometryChanged=false};O.prototype.add=function(e){this._chidren.push(e)};O.prototype.destroy=function(){this._ready=false;O.traverse(this,function(e){if(e._drawCommand){delete e._drawCommand}},false);for(var e in this._uniformValueCache){if(this._uniformValueCache.hasOwnProperty(e)){delete this._uniformValueCache[e]}}for(var e in this._textureCache){if(this._textureCache.hasOwnProperty(e)){delete this._textureCache[e]}}for(var e in this._uniformMaps){if(this._uniformMaps.hasOwnProperty(e)){delete this._uniformMaps[e]}}for(var e in this._framebufferTextures){if(this._framebufferTextures.hasOwnProperty(e)){delete this._framebufferTextures[e]}}this._uniformValueCache={};this._textureCache={};this._uniformMaps={};this._framebufferTextures={};if(this._pickIds){for(e=0;e<this._pickIds.length;++e){this._pickIds[e].destroy&&this._pickIds[e].destroy()}}};O.traverse=function(e,t,n){if(!e){return}F.cancelCurrent=false;if(n&&(!e.show&&!e.visible)){return}if(e.geometry&&e.material||e instanceof o||e instanceof s){t(e,F)}if(F.cancelCurrent){return}else if(e.children){e.children.forEach(function(e){O.traverse(e,t,n)})}},Cesium.defineProperties(O.prototype,{modelMatrixNeedsUpdate:{get:function(){return this._modelMatrixNeedsUpdate},set:function(e){this._modelMatrixNeedsUpdate=e;if(e){O.traverse(this,function(t){t._modelMatrixNeedsUpdate=e},false)}}},showReference:{get:function(){return this.referenceMesh.show},set:function(e){this.referenceMesh.show=e}},children:{get:function(){return this._chidren},set:function(e){this._chidren=e}},show:{get:function(){return this._show},set:function(e){this._show=e}},debug:{get:function(){return this._debug},set:function(e){this._debug=e}},ready:{get:function(){return this._ready}},modelMatrix:{get:function(){return this._modelMatrix},set:function(e){this._modelMatrix=e;this._modelMatrixNeedsUpdate=true}},rotation:{get:function(){return this._rotation},set:function(e){if(e!=this._rotation){this._rotation=e;this._needUpdate=true}this._rotation.paramChanged.removeEventListener(this._onNeedUpdateChanged);this._rotation=e;this._rotation.paramChanged.addEventListener(this._onNeedUpdateChanged)}},position:{get:function(){return this._position},set:function(e){if(e.x!=this._position.x||e.y!=this._position.y||e.z!=this._position.z){this._position=e;this._modelMatrixNeedsUpdate=true}this._position=e}},scale:{get:function(){return this._scale},set:function(e){if(e.x!=this._scale.x||e.y!=this._scale.y||e.z!=this._scale.z){this._scale=e;this._modelMatrixNeedsUpdate=true}this._scale=e}}});return O});n("Core/Shaders/ShaderLib",["Core/Shaders/ShaderChunk"],function(e){var t={common:{diffuse:{value:new Cesium.Color(15658734)},opacity:{value:1},map:{value:null},offsetRepeat:{value:new Cesium.Cartesian4(0,0,1,1)},specularMap:{value:null},alphaMap:{value:null},envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Cesium.Cartesian2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Cesium.Color(16777215)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Cesium.Color(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},offsetRepeat:{value:new Cesium.Cartesian4(0,0,1,1)}}};var n={merge:function(e){var t={};for(var n=0;n<e.length;n++){var i=this.clone(e[n]);for(var r in i){t[r]=i[r]}}return t},clone:function(e){var t={};for(var n in e){t[n]={};for(var i in e[n]){var r=e[n][i];if(r&&(r instanceof Cesium.Color||r instanceof Cesium.Matrix3||r instanceof Cesium.Matrix4||r instanceof Cesium.Cartesian2||r instanceof Cesium.Cartesian3||r instanceof Cesium.Cartesian4)){t[n][i]=r.constructor.clone(r)}else if(Array.isArray(r)){t[n][i]=r.slice()}else{t[n][i]=r}}}return t}};var i={basic:{uniforms:n.merge([t.common,t.aomap,t.lightmap,t.fog]),vertexShader:e.meshbasic_vert,fragmentShader:e.meshbasic_frag},lambert:{uniforms:n.merge([t.common,t.aomap,t.lightmap,t.emissivemap,t.fog,t.lights,{emissive:{value:new Cesium.Color(0)}}]),vertexShader:e.meshlambert_vert,fragmentShader:e.meshlambert_frag},phong:{uniforms:n.merge([t.common,t.aomap,t.lightmap,t.emissivemap,t.bumpmap,t.normalmap,t.displacementmap,t.gradientmap,t.fog,t.lights,{emissive:{value:new Cesium.Color(0)},specular:{value:new Cesium.Color(1118481)},shininess:{value:30}}]),vertexShader:e.meshphong_vert,fragmentShader:e.meshphong_frag},standard:{uniforms:n.merge([t.common,t.aomap,t.lightmap,t.emissivemap,t.bumpmap,t.normalmap,t.displacementmap,t.roughnessmap,t.metalnessmap,t.fog,t.lights,{emissive:{value:new Cesium.Color(0)},roughness:{value:.5},metalness:{value:.5},envMapIntensity:{value:1}}]),vertexShader:e.meshphysical_vert,fragmentShader:e.meshphysical_frag},points:{uniforms:n.merge([t.points,t.fog]),vertexShader:e.points_vert,fragmentShader:e.points_frag},dashed:{uniforms:n.merge([t.common,t.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:e.linedashed_vert,fragmentShader:e.linedashed_frag},depth:{uniforms:n.merge([t.common,t.displacementmap]),vertexShader:e.depth_vert,fragmentShader:e.depth_frag},normal:{uniforms:n.merge([t.common,t.bumpmap,t.normalmap,t.displacementmap,{opacity:{value:1}}]),vertexShader:e.normal_vert,fragmentShader:e.normal_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:e.cube_vert,fragmentShader:e.cube_frag},equirect:{uniforms:{tEquirect:{value:null},tFlip:{value:-1}},vertexShader:e.equirect_vert,fragmentShader:e.equirect_frag},distanceRGBA:{uniforms:{lightPos:{value:new Cesium.Cartesian3}},vertexShader:e.distanceRGBA_vert,fragmentShader:e.distanceRGBA_frag}};i.physical={uniforms:n.merge([i.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:e.meshphysical_vert,fragmentShader:e.meshphysical_frag};return i});n("Core/BasicMeshMaterial",["Core/MeshMaterial","Core/Shaders/ShaderChunk","Core/Shaders/ShaderLib","Util/Path"],function(e,t,n,i){var r=Cesium.WebGLConstants;function a(n){n=n?n:{};n.uniforms=n.uniforms?n.uniforms:{ambientColor:[0,0,0,1],emissionColor:[0,0,0,1],diffuseColor:[0,0,0,1],specularColor:[0,0,0,1],specularShininess:0,alpha:undefined,ambientColorMap:undefined,emissionColorMap:undefined,diffuseColorMap:undefined,specularColorMap:undefined,specularShininessMap:undefined,normalMap:undefined,alphaMap:undefined};n.uniforms.ambientColor=Cesium.defaultValue(n.uniforms.ambientColor,[0,0,0,1]);n.uniforms.emissionColor=Cesium.defaultValue(n.uniforms.emissionColor,[0,0,0,1]);n.uniforms.diffuseColor=Cesium.defaultValue(n.uniforms.diffuseColor,[0,0,0,1]);n.uniforms.specularColor=Cesium.defaultValue(n.uniforms.specularColor,[0,0,0,1]);n.uniforms.alpha=Cesium.defaultValue(n.uniforms.alpha,1);n.uniforms.specularShininess=Cesium.defaultValue(n.uniforms.specularShininess,0);n.side=Cesium.defaultValue(n.side,e.Sides.FRONT);e.apply(this,[n]);this.blendEnable=false;var a=n.withTexture;var o=n.withNormals;this.depthTest=true;this.depthMask=true;this.blending=true;if(n.uniforms.diffuseColorMap){if(typeof n.uniforms.diffuseColorMap==="string"){var s=n.uniforms.diffuseColorMap.toLowerCase();var l=i.GetExtension(s);if(l==".tif"||l==".png"){this.translucent=true}else if(s.slice(0,"data:image/png".length)==="data:image/png"){this.translucent=true}else if(s.slice(0,"data:image/tif".length)==="data:image/tif"){this.translucent=true}}else if(s instanceof HTMLCanvasElement||s instanceof HTMLVideoElement){this.translucent=true}a=true;if(!Cesium.defined(this.uniforms.diffuseColorMap.flipY)){this.uniforms.diffuseColorMap.flipY=false}if(!this.uniforms.diffuseColorMap.sampler){var c={};c.magnificationFilter=r.LINEAR;c.minificationFilter=r.NEAREST_MIPMAP_LINEAR;c.wrapS=r.REPEAT;c.wrapT=r.REPEAT;this.uniforms.diffuseColorMap.sampler=c}}else{a=false}if(Cesium.defined(n.translucent)){this.translucent=n.translucent}var f=null;var d=null;if(a&&o){f=t.texture_normals_vert;d=t.texture_normals_frag}else if(a&&!o){f=t.texture_vert;d=t.texture_frag}else if(!a&&o){f=t.normals_vert;d=t.normals_frag}else{f=t.none_vert;d=t.none_frag}this.vertexShader=f;this.fragmentShader=d}a.prototype=new e;return a});n("Core/BasicGeometry",[],function(){function e(e){this.positions=e.positions;this.normals=e.normals;this.uvs=e.uvs;this.indices=e.indices}e.createGeometry=function(e){if(!e.positions){throw new Error("缺少positions参数")}if(!e.indices){throw new Error("缺少indices参数")}var t=e.positions;var n=e.normals;var i=e.uvs;var r=e.indices instanceof Int32Array?e.indices:new Int32Array(e.indices);var a={position:new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t instanceof Float32Array?t:new Float32Array(e.positions)})};if(n){a.normal=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:n instanceof Float32Array?n:new Float32Array(n)})}if(i){a.uv=new Cesium.GeometryAttribute({componentDatatype:Cesium.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:i instanceof Float32Array?i:new Float32Array(i)})}var o=Cesium.BoundingSphere.fromVertices(t);var s=new Cesium.Geometry({attributes:a,indices:new Int32Array(r),primitiveType:Cesium.PrimitiveType.TRIANGLES,boundingSphere:o});return s};return e});n("Core/PlaneBufferGeometry",["Core/BasicGeometry"],function(e){function t(e,t,n,i){this.width=e;this.height=t;this.widthSegments=n;this.heightSegments=i}t.createGeometry=function(t){var n=t.width,i=t.height,r=t.widthSegments,a=t.heightSegments;n=n||1;i=i||1;var o=n/2;var s=i/2;var l=Math.floor(r)||1;var c=Math.floor(a)||1;var f=l+1;var d=c+1;var u=n/l;var m=i/c;var p,h;var v=[];var g=[];var _=[];var x=[];for(h=0;h<d;h++){var C=h*m-s;for(p=0;p<f;p++){var y=p*u-o;g.push(y,-C,0);_.push(0,0,1);x.push(p/l);x.push(1-h/c)}}for(h=0;h<c;h++){for(p=0;p<l;p++){var M=p+f*h;var w=p+f*(h+1);var S=p+1+f*(h+1);var L=p+1+f*h;v.push(M,w,L);v.push(w,S,L)}}return e.createGeometry({positions:new Float32Array(g),normals:new Float32Array(_),uvs:new Float32Array(x),indices:new Int32Array(v)})};return t});n("Main",["Core/RendererUtils","Core/Mesh","Core/MeshMaterial","Core/Shaders/ShaderChunk","Core/MeshVisualizer","Core/FramebufferTexture","Core/GeometryUtils","Core/LOD","Core/PlaneGeometry","Core/Rotation","Core/ReferenceMesh","Core/BasicMeshMaterial","Core/BasicGeometry","Core/Shaders/ShaderLib","Core/PlaneBufferGeometry","Util/CSG","Core/MeshPhongMaterial"],function(e,t,n,i,r,a,o,s,l,c,f,d,u,m,p,h,v){if(typeof Cesium==="undefined"){Cesium={}}Cesium.RendererUtils=e;Cesium.Mesh=t;Cesium.MeshMaterial=n;Cesium.ShaderChunk=i;Cesium.ShaderLib=m;Cesium.MeshVisualizer=r;Cesium.FramebufferTexture=a;Cesium.GeometryUtils=o;Cesium.LOD=s;Cesium.PlaneGeometry=l;Cesium.Rotation=c;Cesium.ReferenceMesh=f;Cesium.BasicMeshMaterial=d;Cesium.BasicGeometry=u;Cesium.PlaneBufferGeometry=p;Cesium.CSG=h;Cesium.MeshPhongMaterial=v;return Cesium});t(["Main"],function(e){"use strict";var t=typeof window!=="undefined"?window:typeof self!=="undefined"?self:{};t.Cesium=e;if(t.onLoad){t.onLoad(e)}},undefined,true)})();if(typeof define==="function"){define(function(){var e=Cesium;Cesium=undefined;return e})}else if(typeof module==="undefined"){window.Cesium=Cesium}else{module.exports=Cesium}
